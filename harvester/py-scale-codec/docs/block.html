<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>scalecodec.block API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scalecodec.block</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Python SCALE Codec Library
#
# Copyright 2018-2020 Stichting Polkascan (Polkascan Foundation).
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from hashlib import blake2b
from collections import OrderedDict

from scalecodec.base import ScaleDecoder, ScaleBytes
from scalecodec.types import FixedLengthArray
from scalecodec.metadata import MetadataDecoder
from scalecodec.types import Vec, Enum, Bytes, Struct


class Extrinsic(ScaleDecoder):
    type_mapping = (
        (&#39;extrinsic_length&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;version_info&#39;, &#39;u8&#39;),
        (&#39;address&#39;, &#39;Address&#39;),
        (&#39;signature&#39;, &#39;Signature&#39;),
        (&#39;nonce&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;era&#39;, &#39;Era&#39;),
        (&#39;call_index&#39;, &#39;(u8,u8)&#39;),
    )

    def __init__(self, data=None, sub_type=None, metadata: MetadataDecoder = None, runtime_config=None, address_type=42):

        assert (type(metadata) == MetadataDecoder)

        self.metadata = metadata
        self.address_type = address_type
        self.extrinsic_length = None
        self.extrinsic_hash = None
        self.version_info = None
        self.contains_transaction = False
        self.address = None
        self.signature_version = None
        self.signature = None
        self.nonce = None
        self.era = None
        self.tip = None
        self.call_index = None
        self.call_module = None
        self.call = None
        self.call_args = None
        self.params_raw = None
        self.params = []
        super().__init__(data, sub_type=sub_type, runtime_config=runtime_config)

    def generate_hash(self):
        if self.contains_transaction:
            return blake2b(self.data.data, digest_size=32).digest().hex()

    def process(self):
        # TODO for all attributes

        attribute_types = OrderedDict(self.type_mapping)

        self.extrinsic_length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        if self.extrinsic_length != self.data.get_remaining_length():
            # Fallback for legacy version
            self.extrinsic_length = None
            self.data.reset()

        self.version_info = self.get_next_bytes(1).hex()

        self.contains_transaction = int(self.version_info, 16) &gt;= 80

        if self.version_info == &#39;01&#39; or self.version_info == &#39;81&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.nonce = self.process_type(attribute_types[&#39;nonce&#39;])

                self.era = self.process_type(&#39;Era&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;02&#39; or self.version_info == &#39;82&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;03&#39; or self.version_info == &#39;83&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;04&#39; or self.version_info == &#39;84&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                multi_signature = self.process_type(&#34;MultiSignature&#34;)

                self.signature_version = multi_signature.index

                self.signature = multi_signature.get_enum_value()

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()
        else:
            raise NotImplementedError(&#39;Extrinsics version &#34;{}&#34; is not implemented&#39;.format(self.version_info))

        if self.call_index:

            self.params_raw = self.data.data[self.data.offset:]

            # Decode params

            self.call = self.metadata.call_index[self.call_index][1]
            self.call_module = self.metadata.call_index[self.call_index][0]

            for arg in self.call.args:

                arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

                self.params.append({
                    &#39;name&#39;: arg.name,
                    &#39;type&#39;: arg.type,
                    &#39;value&#39;: arg_type_obj.serialize()
                })

        result = {
            &#39;extrinsic_length&#39;: self.extrinsic_length,
            &#39;version_info&#39;: self.version_info,
        }

        if self.contains_transaction:
            result[&#39;account_length&#39;] = self.address.account_length
            result[&#39;account_id&#39;] = self.address.account_id
            result[&#39;account_index&#39;] = self.address.account_index
            result[&#39;account_idx&#39;] = self.address.account_idx
            result[&#39;signature_version&#39;] = self.signature_version
            result[&#39;signature&#39;] = self.signature.replace(&#39;0x&#39;, &#39;&#39;)
            result[&#39;extrinsic_hash&#39;] = self.extrinsic_hash
        if self.call_index:
            result[&#39;call_code&#39;] = self.call_index
            result[&#39;call_function&#39;] = self.call.get_identifier()
            result[&#39;call_module&#39;] = self.call_module.get_identifier()

        if self.nonce:
            result[&#39;nonce&#39;] = self.nonce.value

        if self.era:
            result[&#39;era&#39;] = self.era.value

        if self.tip:
            result[&#39;tip&#39;] = self.tip.value

        result[&#39;params&#39;] = self.params

        return result

    def process_encode(self, value):

        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call) in self.metadata.call_index.items():
                if call_module.name.lower() == value[&#39;call_module&#39;].lower() and call.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call = call
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call:
            raise ValueError(&#39;No call module and function specified&#39;)

        # Determine version (Fixed to V4 for now)
        if &#39;account_id&#39; in value:
            self.version_info = &#39;84&#39;
            self.contains_transaction = True
        else:
            self.version_info = &#39;04&#39;
            self.contains_transaction = False

        if self.contains_transaction:
            data = ScaleBytes(&#39;0x84&#39;)

            self.address = self.get_decoder_class(&#39;Address&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
            data += self.address.encode(value[&#39;account_id&#39;])

            self.signature_version = self.get_decoder_class(
                &#39;U8&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.signature_version.encode(value[&#39;signature_version&#39;])

            self.signature = self.get_decoder_class(
                &#39;Signature&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.signature.encode(&#39;0x{}&#39;.format(value[&#39;signature&#39;].replace(&#39;0x&#39;, &#39;&#39;)))

            self.era = self.get_decoder_class(&#39;Era&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
            data += self.era.encode(value[&#39;era&#39;])

            self.nonce = self.get_decoder_class(
                &#39;Compact&lt;Index&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.nonce.encode(value[&#39;nonce&#39;])

            self.tip = self.get_decoder_class(
                &#39;Compact&lt;Balance&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.tip.encode(value[&#39;tip&#39;])

        else:
            data = ScaleBytes(&#39;0x04&#39;)

        data += ScaleBytes(bytearray.fromhex(self.call_index))

        # Convert params to call_args TODO refactor
        if not value.get(&#39;call_args&#39;) and value.get(&#39;params&#39;):
            value[&#39;call_args&#39;] = {call_arg[&#39;name&#39;]: call_arg[&#39;value&#39;] for call_arg in value.get(&#39;params&#39;)}

        # Encode call params
        if len(self.call.args) &gt; 0:
            for arg in self.call.args:
                if arg.name not in value.get(&#39;call_args&#39;, {}):
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(
                        type_string=arg.type, metadata=self.metadata, runtime_config=self.runtime_config
                    )
                    data += arg_obj.encode(param_value)

        # Wrap payload with a length Compact&lt;u32&gt;
        length_obj = self.get_decoder_class(&#39;Compact&lt;u32&gt;&#39;, runtime_config=self.runtime_config)
        data = length_obj.encode(data.length) + data

        return data

    def __repr__(self):
        return &#34;&lt;{}(hash={})&gt;&#34;.format(self.__class__.__name__, self.extrinsic_hash)


# Deprecated
class ExtrinsicsDecoder(Extrinsic):
    pass


class EventsDecoder(Vec):
    type_string = &#39;Vec&lt;EventRecord&lt;Event, Hash&gt;&gt;&#39;

    def __init__(self, data, metadata=None, **kwargs):
        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata
        self.elements = []

        super().__init__(data, metadata=metadata, **kwargs)

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        for i in range(0, element_count):
            element = self.process_type(&#39;EventRecord&#39;, metadata=self.metadata)
            element.value[&#39;event_idx&#39;] = i
            self.elements.append(element)

        return [e.value for e in self.elements]


class GenericEvent(ScaleDecoder):

    def __init__(self, data, sub_type=None, metadata: MetadataDecoder = None):

        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata

        self.extrinsic_idx = None
        self.type = None
        self.params = []
        self.event = None
        self.event_module = None

        super().__init__(data, sub_type)

    def process(self):

        self.type = self.get_next_bytes(2).hex()

        # Decode params

        self.event = self.metadata.event_index[self.type][1]
        self.event_module = self.metadata.event_index[self.type][0]

        for arg_type in self.event.args:
            arg_type_obj = self.process_type(arg_type)

            self.params.append({
                &#39;type&#39;: arg_type,
                &#39;value&#39;: arg_type_obj.serialize()
            })

        return {
            &#39;extrinsic_idx&#39;: self.extrinsic_idx,
            &#39;type&#39;: self.type,
            &#39;module_id&#39;: self.event_module.name,
            &#39;event_id&#39;: self.event.name,
            &#39;params&#39;: self.params,
        }


class EventRecord(ScaleDecoder):

    def __init__(self, data, sub_type=None, metadata: MetadataDecoder = None, **kwargs):

        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata

        self.phase = None
        self.extrinsic_idx = None
        self.type = None
        self.params = []
        self.event = None
        self.event_module = None
        self.topics = []

        super().__init__(data, sub_type, **kwargs)

    def process(self):

        # TODO Create option type
        self.phase = self.get_next_u8()

        if self.phase == 0:
            self.extrinsic_idx = self.process_type(&#39;U32&#39;).value

        self.type = self.get_next_bytes(2).hex()

        # Decode params

        self.event = self.metadata.event_index[self.type][1]
        self.event_module = self.metadata.event_index[self.type][0]

        for arg_type in self.event.args:
            arg_type_obj = self.process_type(arg_type)

            self.params.append({
                &#39;type&#39;: arg_type,
                &#39;value&#39;: arg_type_obj.serialize()
            })

        # Topics introduced since MetadataV5
        if self.metadata.version and self.metadata.version.index &gt;= 5:
            self.topics = self.process_type(&#39;Vec&lt;Hash&gt;&#39;).value

        return {
            &#39;phase&#39;: self.phase,
            &#39;extrinsic_idx&#39;: self.extrinsic_idx,
            &#39;type&#39;: self.type,
            &#39;module_id&#39;: self.event_module.name,
            &#39;event_id&#39;: self.event.name,
            &#39;params&#39;: self.params,
            &#39;topics&#39;: self.topics
        }


class Other(Bytes):
    pass


class AuthoritiesChange(Vec):
    type_string = &#39;Vec&lt;AccountId&gt;&#39;

    def __init__(self, data, **kwargs):

        super().__init__(data, sub_type=&#39;AccountId&#39;, **kwargs)


class GenericConsensusEngineId(FixedLengthArray):
    sub_type = &#39;u8&#39;
    element_count = 4

    def process(self):
        return self.get_next_bytes(self.element_count).decode()


class ChangesTrieRoot(Bytes):
    pass


class SealV0(Struct):
    type_string = &#39;(u64, Signature)&#39;

    type_mapping = ((&#39;slot&#39;, &#39;u64&#39;), (&#39;signature&#39;, &#39;Signature&#39;))


class Consensus(Struct):
    type_string = &#39;(ConsensusEngineId, Vec&lt;u8&gt;)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))


class Seal(Struct):
    type_string = &#39;(ConsensusEngineId, Bytes)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))


class PreRuntime(Struct):
    type_string = &#39;(ConsensusEngineId, Bytes)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))


class LogDigest(Enum):

    value_list = [&#39;Other&#39;, &#39;AuthoritiesChange&#39;, &#39;ChangesTrieRoot&#39;, &#39;SealV0&#39;, &#39;Consensus&#39;, &#39;Seal&#39;, &#39;PreRuntime&#39;]

    def __init__(self, data, **kwargs):
        self.log_type = None
        self.index_value = None
        super().__init__(data, **kwargs)

    def process(self):
        self.index = int(self.get_next_bytes(1).hex())
        self.index_value = self.value_list[self.index]
        self.log_type = self.process_type(self.value_list[self.index])

        return {&#39;type&#39;: self.log_type.type_string, &#39;value&#39;: self.log_type.value}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scalecodec.block.AuthoritiesChange"><code class="flex name class">
<span>class <span class="ident">AuthoritiesChange</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthoritiesChange(Vec):
    type_string = &#39;Vec&lt;AccountId&gt;&#39;

    def __init__(self, data, **kwargs):

        super().__init__(data, sub_type=&#39;AccountId&#39;, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Vec" href="types.html#scalecodec.types.Vec">Vec</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.AuthoritiesChange.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Vec" href="types.html#scalecodec.types.Vec">Vec</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Vec.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.ChangesTrieRoot"><code class="flex name class">
<span>class <span class="ident">ChangesTrieRoot</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangesTrieRoot(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="types.html#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="types.html#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.Consensus"><code class="flex name class">
<span>class <span class="ident">Consensus</span></span>
<span>(</span><span>data=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Consensus(Struct):
    type_string = &#39;(ConsensusEngineId, Vec&lt;u8&gt;)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.Consensus.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.block.Consensus.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.EventRecord"><code class="flex name class">
<span>class <span class="ident">EventRecord</span></span>
<span>(</span><span>data, sub_type=None, metadata: <a title="scalecodec.metadata.MetadataDecoder" href="metadata.html#scalecodec.metadata.MetadataDecoder">MetadataDecoder</a> = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventRecord(ScaleDecoder):

    def __init__(self, data, sub_type=None, metadata: MetadataDecoder = None, **kwargs):

        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata

        self.phase = None
        self.extrinsic_idx = None
        self.type = None
        self.params = []
        self.event = None
        self.event_module = None
        self.topics = []

        super().__init__(data, sub_type, **kwargs)

    def process(self):

        # TODO Create option type
        self.phase = self.get_next_u8()

        if self.phase == 0:
            self.extrinsic_idx = self.process_type(&#39;U32&#39;).value

        self.type = self.get_next_bytes(2).hex()

        # Decode params

        self.event = self.metadata.event_index[self.type][1]
        self.event_module = self.metadata.event_index[self.type][0]

        for arg_type in self.event.args:
            arg_type_obj = self.process_type(arg_type)

            self.params.append({
                &#39;type&#39;: arg_type,
                &#39;value&#39;: arg_type_obj.serialize()
            })

        # Topics introduced since MetadataV5
        if self.metadata.version and self.metadata.version.index &gt;= 5:
            self.topics = self.process_type(&#39;Vec&lt;Hash&gt;&#39;).value

        return {
            &#39;phase&#39;: self.phase,
            &#39;extrinsic_idx&#39;: self.extrinsic_idx,
            &#39;type&#39;: self.type,
            &#39;module_id&#39;: self.event_module.name,
            &#39;event_id&#39;: self.event.name,
            &#39;params&#39;: self.params,
            &#39;topics&#39;: self.topics
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.EventRecord.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    # TODO Create option type
    self.phase = self.get_next_u8()

    if self.phase == 0:
        self.extrinsic_idx = self.process_type(&#39;U32&#39;).value

    self.type = self.get_next_bytes(2).hex()

    # Decode params

    self.event = self.metadata.event_index[self.type][1]
    self.event_module = self.metadata.event_index[self.type][0]

    for arg_type in self.event.args:
        arg_type_obj = self.process_type(arg_type)

        self.params.append({
            &#39;type&#39;: arg_type,
            &#39;value&#39;: arg_type_obj.serialize()
        })

    # Topics introduced since MetadataV5
    if self.metadata.version and self.metadata.version.index &gt;= 5:
        self.topics = self.process_type(&#39;Vec&lt;Hash&gt;&#39;).value

    return {
        &#39;phase&#39;: self.phase,
        &#39;extrinsic_idx&#39;: self.extrinsic_idx,
        &#39;type&#39;: self.type,
        &#39;module_id&#39;: self.event_module.name,
        &#39;event_id&#39;: self.event.name,
        &#39;params&#39;: self.params,
        &#39;topics&#39;: self.topics
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleDecoder.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.EventsDecoder"><code class="flex name class">
<span>class <span class="ident">EventsDecoder</span></span>
<span>(</span><span>data, metadata=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventsDecoder(Vec):
    type_string = &#39;Vec&lt;EventRecord&lt;Event, Hash&gt;&gt;&#39;

    def __init__(self, data, metadata=None, **kwargs):
        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata
        self.elements = []

        super().__init__(data, metadata=metadata, **kwargs)

    def process(self):
        element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        for i in range(0, element_count):
            element = self.process_type(&#39;EventRecord&#39;, metadata=self.metadata)
            element.value[&#39;event_idx&#39;] = i
            self.elements.append(element)

        return [e.value for e in self.elements]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Vec" href="types.html#scalecodec.types.Vec">Vec</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.EventsDecoder.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.EventsDecoder.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    element_count = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

    for i in range(0, element_count):
        element = self.process_type(&#39;EventRecord&#39;, metadata=self.metadata)
        element.value[&#39;event_idx&#39;] = i
        self.elements.append(element)

    return [e.value for e in self.elements]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Vec" href="types.html#scalecodec.types.Vec">Vec</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Vec.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.Extrinsic"><code class="flex name class">
<span>class <span class="ident">Extrinsic</span></span>
<span>(</span><span>data=None, sub_type=None, metadata: <a title="scalecodec.metadata.MetadataDecoder" href="metadata.html#scalecodec.metadata.MetadataDecoder">MetadataDecoder</a> = None, runtime_config=None, address_type=42)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Extrinsic(ScaleDecoder):
    type_mapping = (
        (&#39;extrinsic_length&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;version_info&#39;, &#39;u8&#39;),
        (&#39;address&#39;, &#39;Address&#39;),
        (&#39;signature&#39;, &#39;Signature&#39;),
        (&#39;nonce&#39;, &#39;Compact&lt;u32&gt;&#39;),
        (&#39;era&#39;, &#39;Era&#39;),
        (&#39;call_index&#39;, &#39;(u8,u8)&#39;),
    )

    def __init__(self, data=None, sub_type=None, metadata: MetadataDecoder = None, runtime_config=None, address_type=42):

        assert (type(metadata) == MetadataDecoder)

        self.metadata = metadata
        self.address_type = address_type
        self.extrinsic_length = None
        self.extrinsic_hash = None
        self.version_info = None
        self.contains_transaction = False
        self.address = None
        self.signature_version = None
        self.signature = None
        self.nonce = None
        self.era = None
        self.tip = None
        self.call_index = None
        self.call_module = None
        self.call = None
        self.call_args = None
        self.params_raw = None
        self.params = []
        super().__init__(data, sub_type=sub_type, runtime_config=runtime_config)

    def generate_hash(self):
        if self.contains_transaction:
            return blake2b(self.data.data, digest_size=32).digest().hex()

    def process(self):
        # TODO for all attributes

        attribute_types = OrderedDict(self.type_mapping)

        self.extrinsic_length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

        if self.extrinsic_length != self.data.get_remaining_length():
            # Fallback for legacy version
            self.extrinsic_length = None
            self.data.reset()

        self.version_info = self.get_next_bytes(1).hex()

        self.contains_transaction = int(self.version_info, 16) &gt;= 80

        if self.version_info == &#39;01&#39; or self.version_info == &#39;81&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.nonce = self.process_type(attribute_types[&#39;nonce&#39;])

                self.era = self.process_type(&#39;Era&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;02&#39; or self.version_info == &#39;82&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;03&#39; or self.version_info == &#39;83&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                self.signature = self.process_type(&#39;Signature&#39;).value

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()

        elif self.version_info == &#39;04&#39; or self.version_info == &#39;84&#39;:

            if self.contains_transaction:
                self.address = self.process_type(&#39;Address&#39;)

                multi_signature = self.process_type(&#34;MultiSignature&#34;)

                self.signature_version = multi_signature.index

                self.signature = multi_signature.get_enum_value()

                self.era = self.process_type(&#39;Era&#39;)

                self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

                self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

                self.extrinsic_hash = self.generate_hash()

            self.call_index = self.get_next_bytes(2).hex()
        else:
            raise NotImplementedError(&#39;Extrinsics version &#34;{}&#34; is not implemented&#39;.format(self.version_info))

        if self.call_index:

            self.params_raw = self.data.data[self.data.offset:]

            # Decode params

            self.call = self.metadata.call_index[self.call_index][1]
            self.call_module = self.metadata.call_index[self.call_index][0]

            for arg in self.call.args:

                arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

                self.params.append({
                    &#39;name&#39;: arg.name,
                    &#39;type&#39;: arg.type,
                    &#39;value&#39;: arg_type_obj.serialize()
                })

        result = {
            &#39;extrinsic_length&#39;: self.extrinsic_length,
            &#39;version_info&#39;: self.version_info,
        }

        if self.contains_transaction:
            result[&#39;account_length&#39;] = self.address.account_length
            result[&#39;account_id&#39;] = self.address.account_id
            result[&#39;account_index&#39;] = self.address.account_index
            result[&#39;account_idx&#39;] = self.address.account_idx
            result[&#39;signature_version&#39;] = self.signature_version
            result[&#39;signature&#39;] = self.signature.replace(&#39;0x&#39;, &#39;&#39;)
            result[&#39;extrinsic_hash&#39;] = self.extrinsic_hash
        if self.call_index:
            result[&#39;call_code&#39;] = self.call_index
            result[&#39;call_function&#39;] = self.call.get_identifier()
            result[&#39;call_module&#39;] = self.call_module.get_identifier()

        if self.nonce:
            result[&#39;nonce&#39;] = self.nonce.value

        if self.era:
            result[&#39;era&#39;] = self.era.value

        if self.tip:
            result[&#39;tip&#39;] = self.tip.value

        result[&#39;params&#39;] = self.params

        return result

    def process_encode(self, value):

        if &#39;call_index&#39; in value:
            self.call_index = value[&#39;call_index&#39;]

        elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
            # Look up call module from metadata
            for call_index, (call_module, call) in self.metadata.call_index.items():
                if call_module.name.lower() == value[&#39;call_module&#39;].lower() and call.name == value[&#39;call_function&#39;]:
                    self.call_index = call_index
                    self.call_module = call_module
                    self.call = call
                    break

            if not self.call_index:
                raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

        elif not self.call_module or not self.call:
            raise ValueError(&#39;No call module and function specified&#39;)

        # Determine version (Fixed to V4 for now)
        if &#39;account_id&#39; in value:
            self.version_info = &#39;84&#39;
            self.contains_transaction = True
        else:
            self.version_info = &#39;04&#39;
            self.contains_transaction = False

        if self.contains_transaction:
            data = ScaleBytes(&#39;0x84&#39;)

            self.address = self.get_decoder_class(&#39;Address&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
            data += self.address.encode(value[&#39;account_id&#39;])

            self.signature_version = self.get_decoder_class(
                &#39;U8&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.signature_version.encode(value[&#39;signature_version&#39;])

            self.signature = self.get_decoder_class(
                &#39;Signature&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.signature.encode(&#39;0x{}&#39;.format(value[&#39;signature&#39;].replace(&#39;0x&#39;, &#39;&#39;)))

            self.era = self.get_decoder_class(&#39;Era&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
            data += self.era.encode(value[&#39;era&#39;])

            self.nonce = self.get_decoder_class(
                &#39;Compact&lt;Index&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.nonce.encode(value[&#39;nonce&#39;])

            self.tip = self.get_decoder_class(
                &#39;Compact&lt;Balance&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
            )
            data += self.tip.encode(value[&#39;tip&#39;])

        else:
            data = ScaleBytes(&#39;0x04&#39;)

        data += ScaleBytes(bytearray.fromhex(self.call_index))

        # Convert params to call_args TODO refactor
        if not value.get(&#39;call_args&#39;) and value.get(&#39;params&#39;):
            value[&#39;call_args&#39;] = {call_arg[&#39;name&#39;]: call_arg[&#39;value&#39;] for call_arg in value.get(&#39;params&#39;)}

        # Encode call params
        if len(self.call.args) &gt; 0:
            for arg in self.call.args:
                if arg.name not in value.get(&#39;call_args&#39;, {}):
                    raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
                else:
                    param_value = value[&#39;call_args&#39;][arg.name]

                    arg_obj = self.get_decoder_class(
                        type_string=arg.type, metadata=self.metadata, runtime_config=self.runtime_config
                    )
                    data += arg_obj.encode(param_value)

        # Wrap payload with a length Compact&lt;u32&gt;
        length_obj = self.get_decoder_class(&#39;Compact&lt;u32&gt;&#39;, runtime_config=self.runtime_config)
        data = length_obj.encode(data.length) + data

        return data

    def __repr__(self):
        return &#34;&lt;{}(hash={})&gt;&#34;.format(self.__class__.__name__, self.extrinsic_hash)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scalecodec.block.ExtrinsicsDecoder" href="#scalecodec.block.ExtrinsicsDecoder">ExtrinsicsDecoder</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.Extrinsic.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.Extrinsic.generate_hash"><code class="name flex">
<span>def <span class="ident">generate_hash</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_hash(self):
    if self.contains_transaction:
        return blake2b(self.data.data, digest_size=32).digest().hex()</code></pre>
</details>
</dd>
<dt id="scalecodec.block.Extrinsic.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    # TODO for all attributes

    attribute_types = OrderedDict(self.type_mapping)

    self.extrinsic_length = self.process_type(&#39;Compact&lt;u32&gt;&#39;).value

    if self.extrinsic_length != self.data.get_remaining_length():
        # Fallback for legacy version
        self.extrinsic_length = None
        self.data.reset()

    self.version_info = self.get_next_bytes(1).hex()

    self.contains_transaction = int(self.version_info, 16) &gt;= 80

    if self.version_info == &#39;01&#39; or self.version_info == &#39;81&#39;:

        if self.contains_transaction:
            self.address = self.process_type(&#39;Address&#39;)

            self.signature = self.process_type(&#39;Signature&#39;).value

            self.nonce = self.process_type(attribute_types[&#39;nonce&#39;])

            self.era = self.process_type(&#39;Era&#39;)

            self.extrinsic_hash = self.generate_hash()

        self.call_index = self.get_next_bytes(2).hex()

    elif self.version_info == &#39;02&#39; or self.version_info == &#39;82&#39;:

        if self.contains_transaction:
            self.address = self.process_type(&#39;Address&#39;)

            self.signature = self.process_type(&#39;Signature&#39;).value

            self.era = self.process_type(&#39;Era&#39;)

            self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

            self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

            self.extrinsic_hash = self.generate_hash()

        self.call_index = self.get_next_bytes(2).hex()

    elif self.version_info == &#39;03&#39; or self.version_info == &#39;83&#39;:

        if self.contains_transaction:
            self.address = self.process_type(&#39;Address&#39;)

            self.signature = self.process_type(&#39;Signature&#39;).value

            self.era = self.process_type(&#39;Era&#39;)

            self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

            self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

            self.extrinsic_hash = self.generate_hash()

        self.call_index = self.get_next_bytes(2).hex()

    elif self.version_info == &#39;04&#39; or self.version_info == &#39;84&#39;:

        if self.contains_transaction:
            self.address = self.process_type(&#39;Address&#39;)

            multi_signature = self.process_type(&#34;MultiSignature&#34;)

            self.signature_version = multi_signature.index

            self.signature = multi_signature.get_enum_value()

            self.era = self.process_type(&#39;Era&#39;)

            self.nonce = self.process_type(&#39;Compact&lt;Index&gt;&#39;)

            self.tip = self.process_type(&#39;Compact&lt;Balance&gt;&#39;)

            self.extrinsic_hash = self.generate_hash()

        self.call_index = self.get_next_bytes(2).hex()
    else:
        raise NotImplementedError(&#39;Extrinsics version &#34;{}&#34; is not implemented&#39;.format(self.version_info))

    if self.call_index:

        self.params_raw = self.data.data[self.data.offset:]

        # Decode params

        self.call = self.metadata.call_index[self.call_index][1]
        self.call_module = self.metadata.call_index[self.call_index][0]

        for arg in self.call.args:

            arg_type_obj = self.process_type(arg.type, metadata=self.metadata)

            self.params.append({
                &#39;name&#39;: arg.name,
                &#39;type&#39;: arg.type,
                &#39;value&#39;: arg_type_obj.serialize()
            })

    result = {
        &#39;extrinsic_length&#39;: self.extrinsic_length,
        &#39;version_info&#39;: self.version_info,
    }

    if self.contains_transaction:
        result[&#39;account_length&#39;] = self.address.account_length
        result[&#39;account_id&#39;] = self.address.account_id
        result[&#39;account_index&#39;] = self.address.account_index
        result[&#39;account_idx&#39;] = self.address.account_idx
        result[&#39;signature_version&#39;] = self.signature_version
        result[&#39;signature&#39;] = self.signature.replace(&#39;0x&#39;, &#39;&#39;)
        result[&#39;extrinsic_hash&#39;] = self.extrinsic_hash
    if self.call_index:
        result[&#39;call_code&#39;] = self.call_index
        result[&#39;call_function&#39;] = self.call.get_identifier()
        result[&#39;call_module&#39;] = self.call_module.get_identifier()

    if self.nonce:
        result[&#39;nonce&#39;] = self.nonce.value

    if self.era:
        result[&#39;era&#39;] = self.era.value

    if self.tip:
        result[&#39;tip&#39;] = self.tip.value

    result[&#39;params&#39;] = self.params

    return result</code></pre>
</details>
</dd>
<dt id="scalecodec.block.Extrinsic.process_encode"><code class="name flex">
<span>def <span class="ident">process_encode</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_encode(self, value):

    if &#39;call_index&#39; in value:
        self.call_index = value[&#39;call_index&#39;]

    elif &#39;call_module&#39; in value and &#39;call_function&#39; in value:
        # Look up call module from metadata
        for call_index, (call_module, call) in self.metadata.call_index.items():
            if call_module.name.lower() == value[&#39;call_module&#39;].lower() and call.name == value[&#39;call_function&#39;]:
                self.call_index = call_index
                self.call_module = call_module
                self.call = call
                break

        if not self.call_index:
            raise ValueError(&#39;Specified call module and function not found in metadata&#39;)

    elif not self.call_module or not self.call:
        raise ValueError(&#39;No call module and function specified&#39;)

    # Determine version (Fixed to V4 for now)
    if &#39;account_id&#39; in value:
        self.version_info = &#39;84&#39;
        self.contains_transaction = True
    else:
        self.version_info = &#39;04&#39;
        self.contains_transaction = False

    if self.contains_transaction:
        data = ScaleBytes(&#39;0x84&#39;)

        self.address = self.get_decoder_class(&#39;Address&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
        data += self.address.encode(value[&#39;account_id&#39;])

        self.signature_version = self.get_decoder_class(
            &#39;U8&#39;, metadata=self.metadata, runtime_config=self.runtime_config
        )
        data += self.signature_version.encode(value[&#39;signature_version&#39;])

        self.signature = self.get_decoder_class(
            &#39;Signature&#39;, metadata=self.metadata, runtime_config=self.runtime_config
        )
        data += self.signature.encode(&#39;0x{}&#39;.format(value[&#39;signature&#39;].replace(&#39;0x&#39;, &#39;&#39;)))

        self.era = self.get_decoder_class(&#39;Era&#39;, metadata=self.metadata, runtime_config=self.runtime_config)
        data += self.era.encode(value[&#39;era&#39;])

        self.nonce = self.get_decoder_class(
            &#39;Compact&lt;Index&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
        )
        data += self.nonce.encode(value[&#39;nonce&#39;])

        self.tip = self.get_decoder_class(
            &#39;Compact&lt;Balance&gt;&#39;, metadata=self.metadata, runtime_config=self.runtime_config
        )
        data += self.tip.encode(value[&#39;tip&#39;])

    else:
        data = ScaleBytes(&#39;0x04&#39;)

    data += ScaleBytes(bytearray.fromhex(self.call_index))

    # Convert params to call_args TODO refactor
    if not value.get(&#39;call_args&#39;) and value.get(&#39;params&#39;):
        value[&#39;call_args&#39;] = {call_arg[&#39;name&#39;]: call_arg[&#39;value&#39;] for call_arg in value.get(&#39;params&#39;)}

    # Encode call params
    if len(self.call.args) &gt; 0:
        for arg in self.call.args:
            if arg.name not in value.get(&#39;call_args&#39;, {}):
                raise ValueError(&#39;Parameter \&#39;{}\&#39; not specified&#39;.format(arg.name))
            else:
                param_value = value[&#39;call_args&#39;][arg.name]

                arg_obj = self.get_decoder_class(
                    type_string=arg.type, metadata=self.metadata, runtime_config=self.runtime_config
                )
                data += arg_obj.encode(param_value)

    # Wrap payload with a length Compact&lt;u32&gt;
    length_obj = self.get_decoder_class(&#39;Compact&lt;u32&gt;&#39;, runtime_config=self.runtime_config)
    data = length_obj.encode(data.length) + data

    return data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleDecoder.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.ExtrinsicsDecoder"><code class="flex name class">
<span>class <span class="ident">ExtrinsicsDecoder</span></span>
<span>(</span><span>data=None, sub_type=None, metadata: <a title="scalecodec.metadata.MetadataDecoder" href="metadata.html#scalecodec.metadata.MetadataDecoder">MetadataDecoder</a> = None, runtime_config=None, address_type=42)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtrinsicsDecoder(Extrinsic):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.block.Extrinsic" href="#scalecodec.block.Extrinsic">Extrinsic</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.block.Extrinsic" href="#scalecodec.block.Extrinsic">Extrinsic</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.block.Extrinsic.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.GenericConsensusEngineId"><code class="flex name class">
<span>class <span class="ident">GenericConsensusEngineId</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericConsensusEngineId(FixedLengthArray):
    sub_type = &#39;u8&#39;
    element_count = 4

    def process(self):
        return self.get_next_bytes(self.element_count).decode()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.FixedLengthArray" href="types.html#scalecodec.types.FixedLengthArray">FixedLengthArray</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.GenericConsensusEngineId.element_count"><code class="name">var <span class="ident">element_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.block.GenericConsensusEngineId.sub_type"><code class="name">var <span class="ident">sub_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.GenericConsensusEngineId.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    return self.get_next_bytes(self.element_count).decode()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.FixedLengthArray" href="types.html#scalecodec.types.FixedLengthArray">FixedLengthArray</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.FixedLengthArray.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.GenericEvent"><code class="flex name class">
<span>class <span class="ident">GenericEvent</span></span>
<span>(</span><span>data, sub_type=None, metadata: <a title="scalecodec.metadata.MetadataDecoder" href="metadata.html#scalecodec.metadata.MetadataDecoder">MetadataDecoder</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericEvent(ScaleDecoder):

    def __init__(self, data, sub_type=None, metadata: MetadataDecoder = None):

        assert (not metadata or type(metadata) == MetadataDecoder)

        self.metadata = metadata

        self.extrinsic_idx = None
        self.type = None
        self.params = []
        self.event = None
        self.event_module = None

        super().__init__(data, sub_type)

    def process(self):

        self.type = self.get_next_bytes(2).hex()

        # Decode params

        self.event = self.metadata.event_index[self.type][1]
        self.event_module = self.metadata.event_index[self.type][0]

        for arg_type in self.event.args:
            arg_type_obj = self.process_type(arg_type)

            self.params.append({
                &#39;type&#39;: arg_type,
                &#39;value&#39;: arg_type_obj.serialize()
            })

        return {
            &#39;extrinsic_idx&#39;: self.extrinsic_idx,
            &#39;type&#39;: self.type,
            &#39;module_id&#39;: self.event_module.name,
            &#39;event_id&#39;: self.event.name,
            &#39;params&#39;: self.params,
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.GenericEvent.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):

    self.type = self.get_next_bytes(2).hex()

    # Decode params

    self.event = self.metadata.event_index[self.type][1]
    self.event_module = self.metadata.event_index[self.type][0]

    for arg_type in self.event.args:
        arg_type_obj = self.process_type(arg_type)

        self.params.append({
            &#39;type&#39;: arg_type,
            &#39;value&#39;: arg_type_obj.serialize()
        })

    return {
        &#39;extrinsic_idx&#39;: self.extrinsic_idx,
        &#39;type&#39;: self.type,
        &#39;module_id&#39;: self.event_module.name,
        &#39;event_id&#39;: self.event.name,
        &#39;params&#39;: self.params,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.base.ScaleDecoder.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.LogDigest"><code class="flex name class">
<span>class <span class="ident">LogDigest</span></span>
<span>(</span><span>data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogDigest(Enum):

    value_list = [&#39;Other&#39;, &#39;AuthoritiesChange&#39;, &#39;ChangesTrieRoot&#39;, &#39;SealV0&#39;, &#39;Consensus&#39;, &#39;Seal&#39;, &#39;PreRuntime&#39;]

    def __init__(self, data, **kwargs):
        self.log_type = None
        self.index_value = None
        super().__init__(data, **kwargs)

    def process(self):
        self.index = int(self.get_next_bytes(1).hex())
        self.index_value = self.value_list[self.index]
        self.log_type = self.process_type(self.value_list[self.index])

        return {&#39;type&#39;: self.log_type.type_string, &#39;value&#39;: self.log_type.value}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Enum" href="types.html#scalecodec.types.Enum">Enum</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.LogDigest.value_list"><code class="name">var <span class="ident">value_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scalecodec.block.LogDigest.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    self.index = int(self.get_next_bytes(1).hex())
    self.index_value = self.value_list[self.index]
    self.log_type = self.process_type(self.value_list[self.index])

    return {&#39;type&#39;: self.log_type.type_string, &#39;value&#39;: self.log_type.value}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Enum" href="types.html#scalecodec.types.Enum">Enum</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Enum.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.Other"><code class="flex name class">
<span>class <span class="ident">Other</span></span>
<span>(</span><span>data=None, sub_type=None, metadata=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Other(Bytes):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Bytes" href="types.html#scalecodec.types.Bytes">Bytes</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Bytes" href="types.html#scalecodec.types.Bytes">Bytes</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Bytes.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.PreRuntime"><code class="flex name class">
<span>class <span class="ident">PreRuntime</span></span>
<span>(</span><span>data=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreRuntime(Struct):
    type_string = &#39;(ConsensusEngineId, Bytes)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.PreRuntime.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.block.PreRuntime.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.Seal"><code class="flex name class">
<span>class <span class="ident">Seal</span></span>
<span>(</span><span>data=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seal(Struct):
    type_string = &#39;(ConsensusEngineId, Bytes)&#39;

    type_mapping = ((&#39;engine&#39;, &#39;ConsensusEngineId&#39;), (&#39;data&#39;, &#39;HexBytes&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.Seal.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.block.Seal.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scalecodec.block.SealV0"><code class="flex name class">
<span>class <span class="ident">SealV0</span></span>
<span>(</span><span>data=None, type_mapping=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sub_type</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>MetadataDecoder</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>runtime_config</code></strong> :&ensp;<code>RuntimeConfigurationObject</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SealV0(Struct):
    type_string = &#39;(u64, Signature)&#39;

    type_mapping = ((&#39;slot&#39;, &#39;u64&#39;), (&#39;signature&#39;, &#39;Signature&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></li>
<li><a title="scalecodec.base.ScaleType" href="base.html#scalecodec.base.ScaleType">ScaleType</a></li>
<li><a title="scalecodec.base.ScaleDecoder" href="base.html#scalecodec.base.ScaleDecoder">ScaleDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scalecodec.block.SealV0.type_mapping"><code class="name">var <span class="ident">type_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scalecodec.block.SealV0.type_string"><code class="name">var <span class="ident">type_string</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scalecodec.types.Struct" href="types.html#scalecodec.types.Struct">Struct</a></b></code>:
<ul class="hlist">
<li><code><a title="scalecodec.types.Struct.get_decoder_class" href="base.html#scalecodec.base.ScaleDecoder.get_decoder_class">get_decoder_class</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scalecodec" href="index.html">scalecodec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scalecodec.block.AuthoritiesChange" href="#scalecodec.block.AuthoritiesChange">AuthoritiesChange</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.AuthoritiesChange.type_string" href="#scalecodec.block.AuthoritiesChange.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.ChangesTrieRoot" href="#scalecodec.block.ChangesTrieRoot">ChangesTrieRoot</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.block.Consensus" href="#scalecodec.block.Consensus">Consensus</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.Consensus.type_mapping" href="#scalecodec.block.Consensus.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.block.Consensus.type_string" href="#scalecodec.block.Consensus.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.EventRecord" href="#scalecodec.block.EventRecord">EventRecord</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.EventRecord.process" href="#scalecodec.block.EventRecord.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.EventsDecoder" href="#scalecodec.block.EventsDecoder">EventsDecoder</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.EventsDecoder.process" href="#scalecodec.block.EventsDecoder.process">process</a></code></li>
<li><code><a title="scalecodec.block.EventsDecoder.type_string" href="#scalecodec.block.EventsDecoder.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.Extrinsic" href="#scalecodec.block.Extrinsic">Extrinsic</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.Extrinsic.generate_hash" href="#scalecodec.block.Extrinsic.generate_hash">generate_hash</a></code></li>
<li><code><a title="scalecodec.block.Extrinsic.process" href="#scalecodec.block.Extrinsic.process">process</a></code></li>
<li><code><a title="scalecodec.block.Extrinsic.process_encode" href="#scalecodec.block.Extrinsic.process_encode">process_encode</a></code></li>
<li><code><a title="scalecodec.block.Extrinsic.type_mapping" href="#scalecodec.block.Extrinsic.type_mapping">type_mapping</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.ExtrinsicsDecoder" href="#scalecodec.block.ExtrinsicsDecoder">ExtrinsicsDecoder</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.block.GenericConsensusEngineId" href="#scalecodec.block.GenericConsensusEngineId">GenericConsensusEngineId</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.GenericConsensusEngineId.element_count" href="#scalecodec.block.GenericConsensusEngineId.element_count">element_count</a></code></li>
<li><code><a title="scalecodec.block.GenericConsensusEngineId.process" href="#scalecodec.block.GenericConsensusEngineId.process">process</a></code></li>
<li><code><a title="scalecodec.block.GenericConsensusEngineId.sub_type" href="#scalecodec.block.GenericConsensusEngineId.sub_type">sub_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.GenericEvent" href="#scalecodec.block.GenericEvent">GenericEvent</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.GenericEvent.process" href="#scalecodec.block.GenericEvent.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.LogDigest" href="#scalecodec.block.LogDigest">LogDigest</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.LogDigest.process" href="#scalecodec.block.LogDigest.process">process</a></code></li>
<li><code><a title="scalecodec.block.LogDigest.value_list" href="#scalecodec.block.LogDigest.value_list">value_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.Other" href="#scalecodec.block.Other">Other</a></code></h4>
</li>
<li>
<h4><code><a title="scalecodec.block.PreRuntime" href="#scalecodec.block.PreRuntime">PreRuntime</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.PreRuntime.type_mapping" href="#scalecodec.block.PreRuntime.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.block.PreRuntime.type_string" href="#scalecodec.block.PreRuntime.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.Seal" href="#scalecodec.block.Seal">Seal</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.Seal.type_mapping" href="#scalecodec.block.Seal.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.block.Seal.type_string" href="#scalecodec.block.Seal.type_string">type_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scalecodec.block.SealV0" href="#scalecodec.block.SealV0">SealV0</a></code></h4>
<ul class="">
<li><code><a title="scalecodec.block.SealV0.type_mapping" href="#scalecodec.block.SealV0.type_mapping">type_mapping</a></code></li>
<li><code><a title="scalecodec.block.SealV0.type_string" href="#scalecodec.block.SealV0.type_string">type_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>