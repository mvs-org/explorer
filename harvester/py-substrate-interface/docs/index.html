<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>substrateinterface API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>substrateinterface</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Python Substrate Interface Library
#
# Copyright 2018-2020 Stichting Polkascan (Polkascan Foundation).
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from .base import *
from .contracts import *

__all__ = (base.__all__ + contracts.__all__)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="substrateinterface.base" href="base.html">substrateinterface.base</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="substrateinterface.constants" href="constants.html">substrateinterface.constants</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="substrateinterface.contracts" href="contracts.html">substrateinterface.contracts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="substrateinterface.exceptions" href="exceptions.html">substrateinterface.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="substrateinterface.utils" href="utils/index.html">substrateinterface.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="substrateinterface.ContractCode"><code class="flex name class">
<span>class <span class="ident">ContractCode</span></span>
<span>(</span><span>code_hash: bytes = None, metadata: <a title="substrateinterface.contracts.ContractMetadata" href="contracts.html#substrateinterface.contracts.ContractMetadata">ContractMetadata</a> = None, wasm_bytes: bytes = None, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object representing the blueprint of the contract, combining either the code hash and metadata of a contract, or
the WASM bytes and metadata</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code_hash</code></strong> :&ensp;<code>code hash</code> of <code>an already uploaded contract WASM binary</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>wasm_bytes</code></strong> :&ensp;<code>WASM binary</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContractCode:

    def __init__(self, code_hash: bytes = None, metadata: ContractMetadata = None, wasm_bytes: bytes = None,
                 substrate: SubstrateInterface = None):
        &#34;&#34;&#34;
        Object representing the blueprint of the contract, combining either the code hash and metadata of a contract, or
        the WASM bytes and metadata

        Parameters
        ----------
        code_hash: code hash of an already uploaded contract WASM binary
        metadata
        wasm_bytes: WASM binary
        substrate
        &#34;&#34;&#34;
        self.code_hash = code_hash
        self.metadata = metadata
        self.wasm_bytes = wasm_bytes
        self.substrate = substrate

    @classmethod
    def create_from_contract_files(cls, wasm_file: str, metadata_file: str,
                                   substrate: SubstrateInterface) -&gt; &#34;ContractCode&#34;:
        &#34;&#34;&#34;
        Create a ContractCode providing paths for the WASM binary file and metadata JSON file generated by the
        ink! project

        Parameters
        ----------
        wasm_file
        metadata_file
        substrate

        Returns
        -------
        ContractCode
        &#34;&#34;&#34;

        with open(os.path.abspath(wasm_file), &#39;rb&#39;) as fp:
            wasm_bytes = fp.read()
            code_hash = blake2b(wasm_bytes, digest_size=32).digest()

        metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

        return cls(code_hash=code_hash, metadata=metadata, wasm_bytes=wasm_bytes, substrate=substrate)

    @classmethod
    def create_from_code_hash(cls, code_hash: bytes, metadata_file: str,
                              substrate: SubstrateInterface) -&gt; &#34;ContractCode&#34;:
        &#34;&#34;&#34;
        Create a ContractCode providing an existing contract code hash and a path to the metadata JSON file

        Parameters
        ----------
        code_hash
        metadata_file
        substrate

        Returns
        -------
        ContractCode
        &#34;&#34;&#34;

        metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

        return cls(code_hash=code_hash, metadata=metadata, substrate=substrate)

    def upload_wasm(self, keypair: Keypair) -&gt; ExtrinsicReceipt:
        &#34;&#34;&#34;
        Created and submits an &#34;Contracts.put_code&#34; extrinsic containing the WASM binary

        Parameters
        ----------
        keypair

        Returns
        -------
        ExtrinsicReceipt
        &#34;&#34;&#34;
        if not self.wasm_bytes:
            raise ValueError(&#34;No WASM bytes to upload&#34;)

        call = self.substrate.compose_call(
            call_module=&#39;Contracts&#39;,
            call_function=&#39;put_code&#39;,
            call_params={
                &#39;code&#39;: &#39;0x{}&#39;.format(self.wasm_bytes.hex())
            }
        )

        extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

        return self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)

    def deploy(self, keypair, endowment, gas_limit, constructor, args: dict = None) -&gt; &#34;ContractInstance&#34;:
        &#34;&#34;&#34;
        Deploys a new instance of the contract after its been uploaded on-chain, with provided constructor and
        constructor arguments

        Parameters
        ----------
        keypair
        endowment: Initial deposit for the newly created contract address
        gas_limit:
        constructor: name of the constructor to use, provided in the metadata
        args: arguments for the constructor

        Returns
        -------
        ContractInstance
        &#34;&#34;&#34;

        # Lookup constructor
        data = self.metadata.generate_constructor_data(name=constructor, args=args)

        call = self.substrate.compose_call(
            call_module=&#39;Contracts&#39;,
            call_function=&#39;instantiate&#39;,
            call_params={
                &#39;endowment&#39;: endowment,
                &#39;gas_limit&#39;: gas_limit,
                &#39;code_hash&#39;: f&#39;0x{self.code_hash.hex()}&#39;,
                &#39;data&#39;: data.to_hex()
            }
        )

        extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

        result = self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)

        if not result.is_success:
            raise ExtrinsicFailedException(result.error_message)

        for event in result.triggered_events:
            if event.event.name == &#39;Instantiated&#39;:
                return ContractInstance(
                    contract_address=self.substrate.ss58_encode(event.params[1][&#39;value&#39;]),
                    metadata=self.metadata,
                    substrate=self.substrate
                )

        raise DeployContractFailedException()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="substrateinterface.ContractCode.create_from_code_hash"><code class="name flex">
<span>def <span class="ident">create_from_code_hash</span></span>(<span>code_hash: bytes, metadata_file: str, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a>) ‑> <a title="substrateinterface.contracts.ContractCode" href="contracts.html#substrateinterface.contracts.ContractCode">ContractCode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a ContractCode providing an existing contract code hash and a path to the metadata JSON file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_file</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractCode" href="#substrateinterface.ContractCode">ContractCode</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_code_hash(cls, code_hash: bytes, metadata_file: str,
                          substrate: SubstrateInterface) -&gt; &#34;ContractCode&#34;:
    &#34;&#34;&#34;
    Create a ContractCode providing an existing contract code hash and a path to the metadata JSON file

    Parameters
    ----------
    code_hash
    metadata_file
    substrate

    Returns
    -------
    ContractCode
    &#34;&#34;&#34;

    metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

    return cls(code_hash=code_hash, metadata=metadata, substrate=substrate)</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractCode.create_from_contract_files"><code class="name flex">
<span>def <span class="ident">create_from_contract_files</span></span>(<span>wasm_file: str, metadata_file: str, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a>) ‑> <a title="substrateinterface.contracts.ContractCode" href="contracts.html#substrateinterface.contracts.ContractCode">ContractCode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a ContractCode providing paths for the WASM binary file and metadata JSON file generated by the
ink! project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wasm_file</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_file</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractCode" href="#substrateinterface.ContractCode">ContractCode</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_contract_files(cls, wasm_file: str, metadata_file: str,
                               substrate: SubstrateInterface) -&gt; &#34;ContractCode&#34;:
    &#34;&#34;&#34;
    Create a ContractCode providing paths for the WASM binary file and metadata JSON file generated by the
    ink! project

    Parameters
    ----------
    wasm_file
    metadata_file
    substrate

    Returns
    -------
    ContractCode
    &#34;&#34;&#34;

    with open(os.path.abspath(wasm_file), &#39;rb&#39;) as fp:
        wasm_bytes = fp.read()
        code_hash = blake2b(wasm_bytes, digest_size=32).digest()

    metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

    return cls(code_hash=code_hash, metadata=metadata, wasm_bytes=wasm_bytes, substrate=substrate)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.ContractCode.deploy"><code class="name flex">
<span>def <span class="ident">deploy</span></span>(<span>self, keypair, endowment, gas_limit, constructor, args: dict = None) ‑> <a title="substrateinterface.contracts.ContractInstance" href="contracts.html#substrateinterface.contracts.ContractInstance">ContractInstance</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deploys a new instance of the contract after its been uploaded on-chain, with provided constructor and
constructor arguments</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keypair</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>endowment</code></strong> :&ensp;<code>Initial deposit for the newly created contract address</code></dt>
<dd>&nbsp;</dd>
<dt>gas_limit:</dt>
<dt><strong><code>constructor</code></strong> :&ensp;<code>name</code> of <code>the constructor to use, provided in the metadata</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>arguments for the constructor</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractInstance" href="#substrateinterface.ContractInstance">ContractInstance</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deploy(self, keypair, endowment, gas_limit, constructor, args: dict = None) -&gt; &#34;ContractInstance&#34;:
    &#34;&#34;&#34;
    Deploys a new instance of the contract after its been uploaded on-chain, with provided constructor and
    constructor arguments

    Parameters
    ----------
    keypair
    endowment: Initial deposit for the newly created contract address
    gas_limit:
    constructor: name of the constructor to use, provided in the metadata
    args: arguments for the constructor

    Returns
    -------
    ContractInstance
    &#34;&#34;&#34;

    # Lookup constructor
    data = self.metadata.generate_constructor_data(name=constructor, args=args)

    call = self.substrate.compose_call(
        call_module=&#39;Contracts&#39;,
        call_function=&#39;instantiate&#39;,
        call_params={
            &#39;endowment&#39;: endowment,
            &#39;gas_limit&#39;: gas_limit,
            &#39;code_hash&#39;: f&#39;0x{self.code_hash.hex()}&#39;,
            &#39;data&#39;: data.to_hex()
        }
    )

    extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

    result = self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)

    if not result.is_success:
        raise ExtrinsicFailedException(result.error_message)

    for event in result.triggered_events:
        if event.event.name == &#39;Instantiated&#39;:
            return ContractInstance(
                contract_address=self.substrate.ss58_encode(event.params[1][&#39;value&#39;]),
                metadata=self.metadata,
                substrate=self.substrate
            )

    raise DeployContractFailedException()</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractCode.upload_wasm"><code class="name flex">
<span>def <span class="ident">upload_wasm</span></span>(<span>self, keypair: <a title="substrateinterface.base.Keypair" href="base.html#substrateinterface.base.Keypair">Keypair</a>) ‑> <a title="substrateinterface.base.ExtrinsicReceipt" href="base.html#substrateinterface.base.ExtrinsicReceipt">ExtrinsicReceipt</a></span>
</code></dt>
<dd>
<div class="desc"><p>Created and submits an "Contracts.put_code" extrinsic containing the WASM binary</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keypair</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ExtrinsicReceipt" href="#substrateinterface.ExtrinsicReceipt">ExtrinsicReceipt</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_wasm(self, keypair: Keypair) -&gt; ExtrinsicReceipt:
    &#34;&#34;&#34;
    Created and submits an &#34;Contracts.put_code&#34; extrinsic containing the WASM binary

    Parameters
    ----------
    keypair

    Returns
    -------
    ExtrinsicReceipt
    &#34;&#34;&#34;
    if not self.wasm_bytes:
        raise ValueError(&#34;No WASM bytes to upload&#34;)

    call = self.substrate.compose_call(
        call_module=&#39;Contracts&#39;,
        call_function=&#39;put_code&#39;,
        call_params={
            &#39;code&#39;: &#39;0x{}&#39;.format(self.wasm_bytes.hex())
        }
    )

    extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

    return self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="substrateinterface.ContractExecutionReceipt"><code class="flex name class">
<span>class <span class="ident">ContractExecutionReceipt</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Object extending the <code><a title="substrateinterface.ExtrinsicReceipt" href="#substrateinterface.ExtrinsicReceipt">ExtrinsicReceipt</a></code> containing more information about the result after submitting a
"Contracts.call" extrinsic.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContractExecutionReceipt(ExtrinsicReceipt):

    def __init__(self, *args, **kwargs):
        &#34;&#34;&#34;
        Object extending the `ExtrinsicReceipt` containing more information about the result after submitting a
        &#34;Contracts.call&#34; extrinsic.

        Parameters
        ----------
        args
        kwargs
        &#34;&#34;&#34;
        self.__contract_events = None
        self.contract_metadata = kwargs.pop(&#39;contract_metadata&#39;)
        super(ContractExecutionReceipt, self).__init__(*args, **kwargs)

    @classmethod
    def create_from_extrinsic_receipt(cls, receipt: ExtrinsicReceipt,
                                      contract_metadata: ContractMetadata) -&gt; &#34;ContractExecutionReceipt&#34;:
        &#34;&#34;&#34;
        Promotes a ExtrinsicReceipt object to a ContractExecutionReceipt. It uses the provided ContractMetadata to
        decode &#34;ContractExecution&#34; events

        Parameters
        ----------
        receipt
        contract_metadata

        Returns
        -------
        ContractExecutionReceipt
        &#34;&#34;&#34;
        return cls(
            substrate=receipt.substrate,
            extrinsic_hash=receipt.extrinsic_hash,
            block_hash=receipt.block_hash,
            finalized=receipt.finalized,
            contract_metadata=contract_metadata
        )

    def process_events(self):
        super().process_events()

        if self.triggered_events:

            self.__contract_events = []

            for event in self.triggered_events:
                if event.event_module.name == &#39;Contracts&#39; and event.event.name == &#39;ContractExecution&#39;:

                    # Create contract event
                    contract_event_obj = ContractEvent(
                        data=ScaleBytes(event.params[1][&#39;value&#39;]),
                        runtime_config=self.substrate.runtime_config,
                        contract_metadata=self.contract_metadata
                    )

                    contract_event_obj.decode()

                    self.__contract_events.append(contract_event_obj)

    @property
    def contract_events(self):
        if self.__contract_events is None:
            self.process_events()

        return self.__contract_events</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="substrateinterface.base.ExtrinsicReceipt" href="base.html#substrateinterface.base.ExtrinsicReceipt">ExtrinsicReceipt</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="substrateinterface.ContractExecutionReceipt.create_from_extrinsic_receipt"><code class="name flex">
<span>def <span class="ident">create_from_extrinsic_receipt</span></span>(<span>receipt: <a title="substrateinterface.base.ExtrinsicReceipt" href="base.html#substrateinterface.base.ExtrinsicReceipt">ExtrinsicReceipt</a>, contract_metadata: <a title="substrateinterface.contracts.ContractMetadata" href="contracts.html#substrateinterface.contracts.ContractMetadata">ContractMetadata</a>) ‑> <a title="substrateinterface.contracts.ContractExecutionReceipt" href="contracts.html#substrateinterface.contracts.ContractExecutionReceipt">ContractExecutionReceipt</a></span>
</code></dt>
<dd>
<div class="desc"><p>Promotes a ExtrinsicReceipt object to a ContractExecutionReceipt. It uses the provided ContractMetadata to
decode "ContractExecution" events</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>receipt</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>contract_metadata</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractExecutionReceipt" href="#substrateinterface.ContractExecutionReceipt">ContractExecutionReceipt</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_extrinsic_receipt(cls, receipt: ExtrinsicReceipt,
                                  contract_metadata: ContractMetadata) -&gt; &#34;ContractExecutionReceipt&#34;:
    &#34;&#34;&#34;
    Promotes a ExtrinsicReceipt object to a ContractExecutionReceipt. It uses the provided ContractMetadata to
    decode &#34;ContractExecution&#34; events

    Parameters
    ----------
    receipt
    contract_metadata

    Returns
    -------
    ContractExecutionReceipt
    &#34;&#34;&#34;
    return cls(
        substrate=receipt.substrate,
        extrinsic_hash=receipt.extrinsic_hash,
        block_hash=receipt.block_hash,
        finalized=receipt.finalized,
        contract_metadata=contract_metadata
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="substrateinterface.ContractExecutionReceipt.contract_events"><code class="name">var <span class="ident">contract_events</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contract_events(self):
    if self.__contract_events is None:
        self.process_events()

    return self.__contract_events</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.ContractExecutionReceipt.process_events"><code class="name flex">
<span>def <span class="ident">process_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_events(self):
    super().process_events()

    if self.triggered_events:

        self.__contract_events = []

        for event in self.triggered_events:
            if event.event_module.name == &#39;Contracts&#39; and event.event.name == &#39;ContractExecution&#39;:

                # Create contract event
                contract_event_obj = ContractEvent(
                    data=ScaleBytes(event.params[1][&#39;value&#39;]),
                    runtime_config=self.substrate.runtime_config,
                    contract_metadata=self.contract_metadata
                )

                contract_event_obj.decode()

                self.__contract_events.append(contract_event_obj)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="substrateinterface.base.ExtrinsicReceipt" href="base.html#substrateinterface.base.ExtrinsicReceipt">ExtrinsicReceipt</a></b></code>:
<ul class="hlist">
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.error_message" href="base.html#substrateinterface.base.ExtrinsicReceipt.error_message">error_message</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.extrinsic" href="base.html#substrateinterface.base.ExtrinsicReceipt.extrinsic">extrinsic</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.extrinsic_idx" href="base.html#substrateinterface.base.ExtrinsicReceipt.extrinsic_idx">extrinsic_idx</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.is_success" href="base.html#substrateinterface.base.ExtrinsicReceipt.is_success">is_success</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.total_fee_amount" href="base.html#substrateinterface.base.ExtrinsicReceipt.total_fee_amount">total_fee_amount</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.triggered_events" href="base.html#substrateinterface.base.ExtrinsicReceipt.triggered_events">triggered_events</a></code></li>
<li><code><a title="substrateinterface.base.ExtrinsicReceipt.weight" href="base.html#substrateinterface.base.ExtrinsicReceipt.weight">weight</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="substrateinterface.ContractInstance"><code class="flex name class">
<span>class <span class="ident">ContractInstance</span></span>
<span>(</span><span>contract_address: str, metadata: <a title="substrateinterface.contracts.ContractMetadata" href="contracts.html#substrateinterface.contracts.ContractMetadata">ContractMetadata</a> = None, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a> = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContractInstance:

    def __init__(self, contract_address: str, metadata: ContractMetadata = None, substrate: SubstrateInterface = None):
        self.substrate = substrate
        self.contract_address = contract_address
        self.metadata = metadata

    @classmethod
    def create_from_address(cls, contract_address: str, metadata_file: str,
                            substrate: SubstrateInterface = None) -&gt; &#34;ContractInstance&#34;:
        &#34;&#34;&#34;
        Create a ContractInstance object that already exists on-chain providing a SS58-address and the path to the
        metadata JSON of that contract

        Parameters
        ----------
        contract_address: SS58-address of contract
        metadata_file: path to metadata JSON generated for contract
        substrate

        Returns
        -------
        ContractInstance
        &#34;&#34;&#34;

        metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

        return cls(contract_address=contract_address, metadata=metadata, substrate=substrate)

    def read(self, keypair: Keypair, method: str, args: dict = None,
             value: int = 0, gas_limit: int = 5000000000000) -&gt; GenericContractExecResult:
        &#34;&#34;&#34;
        Used to execute non-mutable messages to for example read data from the contract using getters. Can also be used
        to predict gas limits and &#39;dry-run&#39; the execution when a mutable message is used.
        This method does not submit an extrinsic.

        Parameters
        ----------
        keypair
        method: name of message to execute
        args: arguments of message in {&#39;name&#39;: value} format
        value: value to send when executing the message
        gas_limit:

        Returns
        -------
        GenericContractExecResult
        &#34;&#34;&#34;

        input_data = self.metadata.generate_message_data(name=method, args=args)

        response = self.substrate.rpc_request(method=&#39;contracts_call&#39;, params=[{
            &#39;dest&#39;: self.contract_address,
            &#39;gasLimit&#39;: gas_limit,
            &#39;inputData&#39;: input_data.to_hex(),
            &#39;origin&#39;: keypair.ss58_address,
            &#39;value&#39;: value
        }])

        if &#39;result&#39; in response:

            if &#39;success&#39; in response[&#39;result&#39;]:

                try:

                    response[&#39;result&#39;][&#39;success&#39;][&#39;data&#39;] = self.substrate.decode_scale(
                        type_string=self.metadata.get_return_type_string_for_message(method),
                        scale_bytes=ScaleBytes(response[&#39;result&#39;][&#39;success&#39;][&#39;data&#39;])
                    )
                except NotImplementedError:
                    pass

            # Wrap the result in a ContractExecResult Enum because the exec will result in the same
            ContractExecResult = self.substrate.runtime_config.get_decoder_class(&#39;ContractExecResult&#39;)

            contract_exec_result = ContractExecResult()
            contract_exec_result.value = response[&#39;result&#39;]
            contract_exec_result.process_contract_result()

            return contract_exec_result

        raise ContractReadFailedException(response)

    def exec(self, keypair: Keypair, method: str, args: dict = None,
             value: int = 0, gas_limit: int = 200000) -&gt; ContractExecutionReceipt:
        &#34;&#34;&#34;
        Executes provided message by creating and submitting an extrinsic. To get a gas prediction or perform a
        &#39;dry-run&#39; of executing this message, see `ContractInstance.read`.

        Parameters
        ----------
        keypair
        method: name of message to execute
        args: arguments of message in {&#39;name&#39;: value} format
        value: value to send when executing the message
        gas_limit

        Returns
        -------
        ContractExecutionReceipt
        &#34;&#34;&#34;

        input_data = self.metadata.generate_message_data(name=method, args=args)

        call = self.substrate.compose_call(
            call_module=&#39;Contracts&#39;,
            call_function=&#39;call&#39;,
            call_params={
                &#39;dest&#39;: self.contract_address,
                &#39;value&#39;: value,
                &#39;gas_limit&#39;: gas_limit,
                &#39;data&#39;: input_data.to_hex()
            }
        )

        extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

        receipt = self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)

        return ContractExecutionReceipt.create_from_extrinsic_receipt(receipt, self.metadata)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="substrateinterface.ContractInstance.create_from_address"><code class="name flex">
<span>def <span class="ident">create_from_address</span></span>(<span>contract_address: str, metadata_file: str, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a> = None) ‑> <a title="substrateinterface.contracts.ContractInstance" href="contracts.html#substrateinterface.contracts.ContractInstance">ContractInstance</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a ContractInstance object that already exists on-chain providing a SS58-address and the path to the
metadata JSON of that contract</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>contract_address</code></strong> :&ensp;<code>SS58-address</code> of <code>contract</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_file</code></strong> :&ensp;<code>path to metadata JSON generated for contract</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractInstance" href="#substrateinterface.ContractInstance">ContractInstance</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_address(cls, contract_address: str, metadata_file: str,
                        substrate: SubstrateInterface = None) -&gt; &#34;ContractInstance&#34;:
    &#34;&#34;&#34;
    Create a ContractInstance object that already exists on-chain providing a SS58-address and the path to the
    metadata JSON of that contract

    Parameters
    ----------
    contract_address: SS58-address of contract
    metadata_file: path to metadata JSON generated for contract
    substrate

    Returns
    -------
    ContractInstance
    &#34;&#34;&#34;

    metadata = ContractMetadata.create_from_file(metadata_file, substrate=substrate)

    return cls(contract_address=contract_address, metadata=metadata, substrate=substrate)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.ContractInstance.exec"><code class="name flex">
<span>def <span class="ident">exec</span></span>(<span>self, keypair: <a title="substrateinterface.base.Keypair" href="base.html#substrateinterface.base.Keypair">Keypair</a>, method: str, args: dict = None, value: int = 0, gas_limit: int = 200000) ‑> <a title="substrateinterface.contracts.ContractExecutionReceipt" href="contracts.html#substrateinterface.contracts.ContractExecutionReceipt">ContractExecutionReceipt</a></span>
</code></dt>
<dd>
<div class="desc"><p>Executes provided message by creating and submitting an extrinsic. To get a gas prediction or perform a
'dry-run' of executing this message, see <code><a title="substrateinterface.ContractInstance.read" href="#substrateinterface.ContractInstance.read">ContractInstance.read()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keypair</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>name</code> of <code>message to execute</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>arguments</code> of <code>message in {'name': value} format</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>value to send when executing the message</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>gas_limit</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractExecutionReceipt" href="#substrateinterface.ContractExecutionReceipt">ContractExecutionReceipt</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec(self, keypair: Keypair, method: str, args: dict = None,
         value: int = 0, gas_limit: int = 200000) -&gt; ContractExecutionReceipt:
    &#34;&#34;&#34;
    Executes provided message by creating and submitting an extrinsic. To get a gas prediction or perform a
    &#39;dry-run&#39; of executing this message, see `ContractInstance.read`.

    Parameters
    ----------
    keypair
    method: name of message to execute
    args: arguments of message in {&#39;name&#39;: value} format
    value: value to send when executing the message
    gas_limit

    Returns
    -------
    ContractExecutionReceipt
    &#34;&#34;&#34;

    input_data = self.metadata.generate_message_data(name=method, args=args)

    call = self.substrate.compose_call(
        call_module=&#39;Contracts&#39;,
        call_function=&#39;call&#39;,
        call_params={
            &#39;dest&#39;: self.contract_address,
            &#39;value&#39;: value,
            &#39;gas_limit&#39;: gas_limit,
            &#39;data&#39;: input_data.to_hex()
        }
    )

    extrinsic = self.substrate.create_signed_extrinsic(call=call, keypair=keypair)

    receipt = self.substrate.submit_extrinsic(extrinsic, wait_for_inclusion=True)

    return ContractExecutionReceipt.create_from_extrinsic_receipt(receipt, self.metadata)</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractInstance.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, keypair: <a title="substrateinterface.base.Keypair" href="base.html#substrateinterface.base.Keypair">Keypair</a>, method: str, args: dict = None, value: int = 0, gas_limit: int = 5000000000000) ‑> scalecodec.types.GenericContractExecResult</span>
</code></dt>
<dd>
<div class="desc"><p>Used to execute non-mutable messages to for example read data from the contract using getters. Can also be used
to predict gas limits and 'dry-run' the execution when a mutable message is used.
This method does not submit an extrinsic.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keypair</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>name</code> of <code>message to execute</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>arguments</code> of <code>message in {'name': value} format</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>value to send when executing the message</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>gas_limit:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>GenericContractExecResult</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, keypair: Keypair, method: str, args: dict = None,
         value: int = 0, gas_limit: int = 5000000000000) -&gt; GenericContractExecResult:
    &#34;&#34;&#34;
    Used to execute non-mutable messages to for example read data from the contract using getters. Can also be used
    to predict gas limits and &#39;dry-run&#39; the execution when a mutable message is used.
    This method does not submit an extrinsic.

    Parameters
    ----------
    keypair
    method: name of message to execute
    args: arguments of message in {&#39;name&#39;: value} format
    value: value to send when executing the message
    gas_limit:

    Returns
    -------
    GenericContractExecResult
    &#34;&#34;&#34;

    input_data = self.metadata.generate_message_data(name=method, args=args)

    response = self.substrate.rpc_request(method=&#39;contracts_call&#39;, params=[{
        &#39;dest&#39;: self.contract_address,
        &#39;gasLimit&#39;: gas_limit,
        &#39;inputData&#39;: input_data.to_hex(),
        &#39;origin&#39;: keypair.ss58_address,
        &#39;value&#39;: value
    }])

    if &#39;result&#39; in response:

        if &#39;success&#39; in response[&#39;result&#39;]:

            try:

                response[&#39;result&#39;][&#39;success&#39;][&#39;data&#39;] = self.substrate.decode_scale(
                    type_string=self.metadata.get_return_type_string_for_message(method),
                    scale_bytes=ScaleBytes(response[&#39;result&#39;][&#39;success&#39;][&#39;data&#39;])
                )
            except NotImplementedError:
                pass

        # Wrap the result in a ContractExecResult Enum because the exec will result in the same
        ContractExecResult = self.substrate.runtime_config.get_decoder_class(&#39;ContractExecResult&#39;)

        contract_exec_result = ContractExecResult()
        contract_exec_result.value = response[&#39;result&#39;]
        contract_exec_result.process_contract_result()

        return contract_exec_result

    raise ContractReadFailedException(response)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="substrateinterface.ContractMetadata"><code class="flex name class">
<span>class <span class="ident">ContractMetadata</span></span>
<span>(</span><span>metadata_dict: dict, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class using the generated metadata.json file to represent the metadata of a contract. The metadata_dict is
parsed and the used types are extracted, composed and added to the type registry of the runtime</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metadata_dict</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContractMetadata:

    def __init__(self, metadata_dict: dict, substrate: SubstrateInterface):
        &#34;&#34;&#34;
        Class using the generated metadata.json file to represent the metadata of a contract. The metadata_dict is
        parsed and the used types are extracted, composed and added to the type registry of the runtime

        Parameters
        ----------
        metadata_dict
        substrate
        &#34;&#34;&#34;
        self.metadata_dict = metadata_dict
        self.substrate = substrate
        self.type_registry = {}

        self.type_string_prefix = f&#34;ink.{self.metadata_dict[&#39;source&#39;][&#39;hash&#39;]}&#34;

        self.__parse_type_registry()

    @classmethod
    def create_from_file(cls, metadata_file: str, substrate: SubstrateInterface) -&gt; &#34;ContractMetadata&#34;:
        &#34;&#34;&#34;
        Create a new ContractMetadata object using the provided metadata_file, usually generated by the command
        &#34;cargo +nightly contract generate-metadata&#34; in an ink! project

        Parameters
        ----------
        metadata_file
        substrate

        Returns
        -------
        ContractMetadata
        &#34;&#34;&#34;
        with open(os.path.abspath(metadata_file), &#39;r&#39;) as fp:
            metadata_string = fp.read()
        return cls(json.loads(metadata_string), substrate)

    def __getattr__(self, item):
        if item in self.metadata_dict:
            return self.metadata_dict[item]
        else:
            raise AttributeError(&#34;&#39;{}&#39; object has no attribute &#39;{}&#39;&#34;.format(self.__class__.__name__, item))

    def __parse_type_registry(self):

        for idx, metadata_type in enumerate(self.metadata_dict[&#39;types&#39;]):
            if idx + 1 not in self.type_registry:
                self.type_registry[idx+1] = self.get_type_string_for_metadata_type(idx+1)

    def generate_constructor_data(self, name, args: dict = None) -&gt; ScaleBytes:
        &#34;&#34;&#34;
        Compose the data field used in the &#34;Contracts.instantiate&#34; call, finding the selectors and encoded the args
        of given constructor

        Parameters
        ----------
        name
        args

        Returns
        -------
        ScaleBytes
        &#34;&#34;&#34;
        if not args:
            args = {}

        for constructor in self.metadata_dict[&#39;spec&#39;][&#39;constructors&#39;]:
            if name in constructor[&#39;name&#39;]:
                data = ScaleBytes(constructor[&#39;selector&#39;])

                for arg in constructor[&#39;args&#39;]:
                    if arg[&#39;name&#39;] not in args:
                        raise ValueError(f&#34;Argument \&#34;{arg[&#39;name&#39;]}\&#34; is missing&#34;)
                    else:
                        data += self.substrate.encode_scale(
                            type_string=self.get_type_string_for_metadata_type(arg[&#39;type&#39;][&#39;type&#39;]),
                            value=args[arg[&#39;name&#39;]]
                        )
                return data

        raise ValueError(f&#39;Constructor &#34;{name}&#34; not found&#39;)

    def get_type_string_for_metadata_type(self, type_id: int) -&gt; str:
        &#34;&#34;&#34;
        Adds a type included in the metadata (represented by an index in the type list) to the type registry and
        produces a type string that can be used in the scope of the `RuntimeConfigurationObject`.

        Parameters
        ----------
        type_id 1-based index of type locating in the metadata types dict

        Returns
        -------
        str
        &#34;&#34;&#34;

        # Check if already processed
        if type_id in self.type_registry:
            return self.type_registry[type_id]

        if type_id &gt; len(self.metadata_dict[&#39;types&#39;]):
            raise ValueError(f&#39;type_id {type_id} not found in metadata&#39;)

        arg_type = self.metadata_dict[&#39;types&#39;][type_id - 1]

        if &#39;path&#39; in arg_type:
            if arg_type[&#39;path&#39;] == [&#39;ink_env&#39;, &#39;types&#39;, &#39;AccountId&#39;]:
                return &#39;AccountId&#39;

        if &#39;primitive&#39; in arg_type[&#39;def&#39;]:
            return arg_type[&#39;def&#39;][&#39;primitive&#39;]

        elif &#39;array&#39; in arg_type[&#39;def&#39;]:
            array_type = self.get_type_string_for_metadata_type(arg_type[&#39;def&#39;][&#39;array&#39;][&#39;type&#39;])
            # Generate unique type string
            return f&#34;[{array_type}; {arg_type[&#39;def&#39;][&#39;array&#39;][&#39;len&#39;]}]&#34;

        elif &#39;variant&#39; in arg_type[&#39;def&#39;]:
            # Create Enum
            type_definition = {
              &#34;type&#34;: &#34;enum&#34;,
              &#34;type_mapping&#34;: []
            }
            for variant in arg_type[&#39;def&#39;][&#39;variant&#39;][&#39;variants&#39;]:

                if &#39;fields&#39; in variant:
                    if len(variant[&#39;fields&#39;]) &gt; 1:
                        raise NotImplementedError(&#39;Tuples as element of enums not supported&#39;)

                    enum_value = self.get_type_string_for_metadata_type(variant[&#39;fields&#39;][0][&#39;type&#39;])

                else:
                    enum_value = &#39;Null&#39;

                type_definition[&#39;type_mapping&#39;].append(
                    [variant[&#39;name&#39;], enum_value]
                )

            # Add to type registry
            self.substrate.runtime_config.update_type_registry_types(
                {f&#39;{self.type_string_prefix}.{type_id}&#39;: type_definition}
            )
            # Generate unique type string
            self.type_registry[type_id] = f&#39;{self.type_string_prefix}.{type_id}&#39;

            return f&#39;{self.type_string_prefix}.{type_id}&#39;

        elif &#39;composite&#39; in arg_type[&#39;def&#39;]:
            # Create Struct
            type_definition = {
                &#34;type&#34;: &#34;struct&#34;,
                &#34;type_mapping&#34;: []
            }

            for field in arg_type[&#39;def&#39;][&#39;composite&#39;][&#39;fields&#39;]:
                type_definition[&#39;type_mapping&#39;].append(
                    [field[&#39;name&#39;], self.get_type_string_for_metadata_type(field[&#39;type&#39;])]
                )

            # Add to type registry
            self.substrate.runtime_config.update_type_registry_types(
                {f&#39;{self.type_string_prefix}.{type_id}&#39;: type_definition}
            )

            # Generate unique type string
            self.type_registry[type_id] = f&#39;{self.type_string_prefix}.{type_id}&#39;

            return f&#39;{self.type_string_prefix}.{type_id}&#39;
        elif &#39;tuple&#39; in arg_type[&#39;def&#39;]:
            # Create tuple
            elements = [self.get_type_string_for_metadata_type(element) for element in arg_type[&#39;def&#39;][&#39;tuple&#39;]]
            return f&#34;({&#39;,&#39;.join(elements)})&#34;

        raise NotImplementedError(f&#34;Type &#39;{arg_type}&#39; not supported&#34;)

    def get_return_type_string_for_message(self, name) -&gt; str:
        for message in self.metadata_dict[&#39;spec&#39;][&#39;messages&#39;]:
            if name in message[&#39;name&#39;]:
                return self.get_type_string_for_metadata_type(message[&#39;returnType&#39;][&#39;type&#39;])

        raise ValueError(f&#39;Message &#34;{name}&#34; not found&#39;)

    def generate_message_data(self, name, args: dict = None) -&gt; ScaleBytes:
        &#34;&#34;&#34;
        Compose the data field used in the &#34;Contracts.call&#34; call, finding the selector and encoded the args
        of provided message name

        Parameters
        ----------
        name: name of message in contract
        args: arguments required by message, in format: `{&#39;name&#39;: value}`

        Returns
        -------
        ScaleBytes
        &#34;&#34;&#34;
        if not args:
            args = {}

        for message in self.metadata_dict[&#39;spec&#39;][&#39;messages&#39;]:
            if name in message[&#39;name&#39;]:
                data = ScaleBytes(message[&#39;selector&#39;])

                for arg in message[&#39;args&#39;]:
                    if arg[&#39;name&#39;] not in args:
                        raise ValueError(f&#34;Argument \&#34;{arg[&#39;name&#39;]}\&#34; is missing&#34;)
                    else:

                        data += self.substrate.encode_scale(
                            type_string=self.get_type_string_for_metadata_type(arg[&#39;type&#39;][&#39;type&#39;]),
                            value=args[arg[&#39;name&#39;]]
                        )
                return data

        raise ValueError(f&#39;Message &#34;{name}&#34; not found&#39;)

    def get_event_data(self, event_id: int) -&gt; dict:
        &#34;&#34;&#34;
        Looks up the event data for given 0-based event_id

        Parameters
        ----------
        event_id

        Returns
        -------

        &#34;&#34;&#34;
        if event_id &gt; len(self.metadata_dict[&#39;spec&#39;][&#39;events&#39;]):
            raise ValueError(f&#39;Event ID {event_id} not found&#39;)

        return self.metadata_dict[&#39;spec&#39;][&#39;events&#39;][event_id]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="substrateinterface.ContractMetadata.create_from_file"><code class="name flex">
<span>def <span class="ident">create_from_file</span></span>(<span>metadata_file: str, substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a>) ‑> <a title="substrateinterface.contracts.ContractMetadata" href="contracts.html#substrateinterface.contracts.ContractMetadata">ContractMetadata</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new ContractMetadata object using the provided metadata_file, usually generated by the command
"cargo +nightly contract generate-metadata" in an ink! project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metadata_file</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.ContractMetadata" href="#substrateinterface.ContractMetadata">ContractMetadata</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_file(cls, metadata_file: str, substrate: SubstrateInterface) -&gt; &#34;ContractMetadata&#34;:
    &#34;&#34;&#34;
    Create a new ContractMetadata object using the provided metadata_file, usually generated by the command
    &#34;cargo +nightly contract generate-metadata&#34; in an ink! project

    Parameters
    ----------
    metadata_file
    substrate

    Returns
    -------
    ContractMetadata
    &#34;&#34;&#34;
    with open(os.path.abspath(metadata_file), &#39;r&#39;) as fp:
        metadata_string = fp.read()
    return cls(json.loads(metadata_string), substrate)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.ContractMetadata.generate_constructor_data"><code class="name flex">
<span>def <span class="ident">generate_constructor_data</span></span>(<span>self, name, args: dict = None) ‑> scalecodec.base.ScaleBytes</span>
</code></dt>
<dd>
<div class="desc"><p>Compose the data field used in the "Contracts.instantiate" call, finding the selectors and encoded the args
of given constructor</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>args</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_constructor_data(self, name, args: dict = None) -&gt; ScaleBytes:
    &#34;&#34;&#34;
    Compose the data field used in the &#34;Contracts.instantiate&#34; call, finding the selectors and encoded the args
    of given constructor

    Parameters
    ----------
    name
    args

    Returns
    -------
    ScaleBytes
    &#34;&#34;&#34;
    if not args:
        args = {}

    for constructor in self.metadata_dict[&#39;spec&#39;][&#39;constructors&#39;]:
        if name in constructor[&#39;name&#39;]:
            data = ScaleBytes(constructor[&#39;selector&#39;])

            for arg in constructor[&#39;args&#39;]:
                if arg[&#39;name&#39;] not in args:
                    raise ValueError(f&#34;Argument \&#34;{arg[&#39;name&#39;]}\&#34; is missing&#34;)
                else:
                    data += self.substrate.encode_scale(
                        type_string=self.get_type_string_for_metadata_type(arg[&#39;type&#39;][&#39;type&#39;]),
                        value=args[arg[&#39;name&#39;]]
                    )
            return data

    raise ValueError(f&#39;Constructor &#34;{name}&#34; not found&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractMetadata.generate_message_data"><code class="name flex">
<span>def <span class="ident">generate_message_data</span></span>(<span>self, name, args: dict = None) ‑> scalecodec.base.ScaleBytes</span>
</code></dt>
<dd>
<div class="desc"><p>Compose the data field used in the "Contracts.call" call, finding the selector and encoded the args
of provided message name</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>name</code> of <code>message in contract</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>args</code></strong> :&ensp;<code _name_:="'name':" value>arguments required by message, in format:</code>``</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScaleBytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_message_data(self, name, args: dict = None) -&gt; ScaleBytes:
    &#34;&#34;&#34;
    Compose the data field used in the &#34;Contracts.call&#34; call, finding the selector and encoded the args
    of provided message name

    Parameters
    ----------
    name: name of message in contract
    args: arguments required by message, in format: `{&#39;name&#39;: value}`

    Returns
    -------
    ScaleBytes
    &#34;&#34;&#34;
    if not args:
        args = {}

    for message in self.metadata_dict[&#39;spec&#39;][&#39;messages&#39;]:
        if name in message[&#39;name&#39;]:
            data = ScaleBytes(message[&#39;selector&#39;])

            for arg in message[&#39;args&#39;]:
                if arg[&#39;name&#39;] not in args:
                    raise ValueError(f&#34;Argument \&#34;{arg[&#39;name&#39;]}\&#34; is missing&#34;)
                else:

                    data += self.substrate.encode_scale(
                        type_string=self.get_type_string_for_metadata_type(arg[&#39;type&#39;][&#39;type&#39;]),
                        value=args[arg[&#39;name&#39;]]
                    )
            return data

    raise ValueError(f&#39;Message &#34;{name}&#34; not found&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractMetadata.get_event_data"><code class="name flex">
<span>def <span class="ident">get_event_data</span></span>(<span>self, event_id: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up the event data for given 0-based event_id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_data(self, event_id: int) -&gt; dict:
    &#34;&#34;&#34;
    Looks up the event data for given 0-based event_id

    Parameters
    ----------
    event_id

    Returns
    -------

    &#34;&#34;&#34;
    if event_id &gt; len(self.metadata_dict[&#39;spec&#39;][&#39;events&#39;]):
        raise ValueError(f&#39;Event ID {event_id} not found&#39;)

    return self.metadata_dict[&#39;spec&#39;][&#39;events&#39;][event_id]</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractMetadata.get_return_type_string_for_message"><code class="name flex">
<span>def <span class="ident">get_return_type_string_for_message</span></span>(<span>self, name) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_return_type_string_for_message(self, name) -&gt; str:
    for message in self.metadata_dict[&#39;spec&#39;][&#39;messages&#39;]:
        if name in message[&#39;name&#39;]:
            return self.get_type_string_for_metadata_type(message[&#39;returnType&#39;][&#39;type&#39;])

    raise ValueError(f&#39;Message &#34;{name}&#34; not found&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.ContractMetadata.get_type_string_for_metadata_type"><code class="name flex">
<span>def <span class="ident">get_type_string_for_metadata_type</span></span>(<span>self, type_id: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a type included in the metadata (represented by an index in the type list) to the type registry and
produces a type string that can be used in the scope of the <code>RuntimeConfigurationObject</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>type_id 1-based index of type locating in the metadata types dict</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_string_for_metadata_type(self, type_id: int) -&gt; str:
    &#34;&#34;&#34;
    Adds a type included in the metadata (represented by an index in the type list) to the type registry and
    produces a type string that can be used in the scope of the `RuntimeConfigurationObject`.

    Parameters
    ----------
    type_id 1-based index of type locating in the metadata types dict

    Returns
    -------
    str
    &#34;&#34;&#34;

    # Check if already processed
    if type_id in self.type_registry:
        return self.type_registry[type_id]

    if type_id &gt; len(self.metadata_dict[&#39;types&#39;]):
        raise ValueError(f&#39;type_id {type_id} not found in metadata&#39;)

    arg_type = self.metadata_dict[&#39;types&#39;][type_id - 1]

    if &#39;path&#39; in arg_type:
        if arg_type[&#39;path&#39;] == [&#39;ink_env&#39;, &#39;types&#39;, &#39;AccountId&#39;]:
            return &#39;AccountId&#39;

    if &#39;primitive&#39; in arg_type[&#39;def&#39;]:
        return arg_type[&#39;def&#39;][&#39;primitive&#39;]

    elif &#39;array&#39; in arg_type[&#39;def&#39;]:
        array_type = self.get_type_string_for_metadata_type(arg_type[&#39;def&#39;][&#39;array&#39;][&#39;type&#39;])
        # Generate unique type string
        return f&#34;[{array_type}; {arg_type[&#39;def&#39;][&#39;array&#39;][&#39;len&#39;]}]&#34;

    elif &#39;variant&#39; in arg_type[&#39;def&#39;]:
        # Create Enum
        type_definition = {
          &#34;type&#34;: &#34;enum&#34;,
          &#34;type_mapping&#34;: []
        }
        for variant in arg_type[&#39;def&#39;][&#39;variant&#39;][&#39;variants&#39;]:

            if &#39;fields&#39; in variant:
                if len(variant[&#39;fields&#39;]) &gt; 1:
                    raise NotImplementedError(&#39;Tuples as element of enums not supported&#39;)

                enum_value = self.get_type_string_for_metadata_type(variant[&#39;fields&#39;][0][&#39;type&#39;])

            else:
                enum_value = &#39;Null&#39;

            type_definition[&#39;type_mapping&#39;].append(
                [variant[&#39;name&#39;], enum_value]
            )

        # Add to type registry
        self.substrate.runtime_config.update_type_registry_types(
            {f&#39;{self.type_string_prefix}.{type_id}&#39;: type_definition}
        )
        # Generate unique type string
        self.type_registry[type_id] = f&#39;{self.type_string_prefix}.{type_id}&#39;

        return f&#39;{self.type_string_prefix}.{type_id}&#39;

    elif &#39;composite&#39; in arg_type[&#39;def&#39;]:
        # Create Struct
        type_definition = {
            &#34;type&#34;: &#34;struct&#34;,
            &#34;type_mapping&#34;: []
        }

        for field in arg_type[&#39;def&#39;][&#39;composite&#39;][&#39;fields&#39;]:
            type_definition[&#39;type_mapping&#39;].append(
                [field[&#39;name&#39;], self.get_type_string_for_metadata_type(field[&#39;type&#39;])]
            )

        # Add to type registry
        self.substrate.runtime_config.update_type_registry_types(
            {f&#39;{self.type_string_prefix}.{type_id}&#39;: type_definition}
        )

        # Generate unique type string
        self.type_registry[type_id] = f&#39;{self.type_string_prefix}.{type_id}&#39;

        return f&#39;{self.type_string_prefix}.{type_id}&#39;
    elif &#39;tuple&#39; in arg_type[&#39;def&#39;]:
        # Create tuple
        elements = [self.get_type_string_for_metadata_type(element) for element in arg_type[&#39;def&#39;][&#39;tuple&#39;]]
        return f&#34;({&#39;,&#39;.join(elements)})&#34;

    raise NotImplementedError(f&#34;Type &#39;{arg_type}&#39; not supported&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt"><code class="flex name class">
<span>class <span class="ident">ExtrinsicReceipt</span></span>
<span>(</span><span>substrate: <a title="substrateinterface.base.SubstrateInterface" href="base.html#substrateinterface.base.SubstrateInterface">SubstrateInterface</a>, extrinsic_hash: str, block_hash: str = None, finalized=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object containing information of submitted extrinsic. Block hash where extrinsic is included is required
when retrieving triggered events or determine if extrinsic was succesfull</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>substrate</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>extrinsic_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>finalized</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtrinsicReceipt:

    def __init__(self, substrate: SubstrateInterface, extrinsic_hash: str, block_hash: str = None, finalized=None):
        &#34;&#34;&#34;
        Object containing information of submitted extrinsic. Block hash where extrinsic is included is required
        when retrieving triggered events or determine if extrinsic was succesfull

        Parameters
        ----------
        substrate
        extrinsic_hash
        block_hash
        finalized
        &#34;&#34;&#34;
        self.substrate = substrate
        self.extrinsic_hash = extrinsic_hash
        self.block_hash = block_hash
        self.finalized = finalized

        self.__extrinsic_idx = None
        self.__extrinsic = None

        self.__triggered_events = None
        self.__is_succes = None
        self.__error_message = None
        self.__weight = None
        self.__total_fee_amount = None

    def retrieve_extrinsic(self):
        if not self.block_hash:
            raise ValueError(&#34;ExtrinsicReceipt can&#39;t retrieve events because it&#39;s unknown which block_hash it is &#34;
                             &#34;included, manually set block_hash or use `wait_for_inclusion` when sending extrinsic&#34;)
        # Determine extrinsic idx

        extrinsics = self.substrate.get_block_extrinsics(block_hash=self.block_hash)

        if len(extrinsics) &gt; 0:
            self.__extrinsic_idx = self.__get_extrinsic_index(
                block_extrinsics=extrinsics,
                extrinsic_hash=self.extrinsic_hash
            )

            self.__extrinsic = extrinsics[self.__extrinsic_idx]

    @property
    def extrinsic_idx(self) -&gt; int:
        &#34;&#34;&#34;
        Retrieves the index of this extrinsic in containing block

        Returns
        -------
        int
        &#34;&#34;&#34;
        if self.__extrinsic_idx is None:
            self.retrieve_extrinsic()
        return self.__extrinsic_idx

    @property
    def extrinsic(self) -&gt; Extrinsic:
        &#34;&#34;&#34;
        Retrieves the `Extrinsic` subject of this receipt

        Returns
        -------
        Extrinsic
        &#34;&#34;&#34;
        if self.__extrinsic is None:
            self.retrieve_extrinsic()
        return self.__extrinsic

    @property
    def triggered_events(self) -&gt; list:
        &#34;&#34;&#34;
        Gets triggered events for submitted extrinsic. block_hash where extrinsic is included is required, manually
        set block_hash or use `wait_for_inclusion` when submitting extrinsic

        Returns
        -------
        list
        &#34;&#34;&#34;
        if self.__triggered_events is None:
            if not self.block_hash:
                raise ValueError(&#34;ExtrinsicReceipt can&#39;t retrieve events because it&#39;s unknown which block_hash it is &#34;
                                 &#34;included, manually set block_hash or use `wait_for_inclusion` when sending extrinsic&#34;)

            if self.extrinsic_idx is None:
                self.retrieve_extrinsic()

            self.__triggered_events = []

            for event in self.substrate.get_events(block_hash=self.block_hash):
                if event.extrinsic_idx == self.extrinsic_idx:
                    self.__triggered_events.append(event)

        return self.__triggered_events

    def process_events(self):
        if self.triggered_events:

            self.__total_fee_amount = 0

            for event in self.triggered_events:
                # Check events
                if event.event_module.name == &#39;System&#39; and event.event.name == &#39;ExtrinsicSuccess&#39;:
                    self.__is_succes = True
                    self.__error_message = None

                    for param in event.params:
                        if param[&#39;type&#39;] == &#39;DispatchInfo&#39;:
                            self.__weight = param[&#39;value&#39;][&#39;weight&#39;]

                if event.event_module.name == &#39;System&#39; and event.event.name == &#39;ExtrinsicFailed&#39;:
                    self.__is_succes = False

                    for param in event.params:
                        if param[&#39;type&#39;] == &#39;DispatchError&#39;:
                            if &#39;Module&#39; in param[&#39;value&#39;]:
                                module_error = self.substrate.metadata_decoder.get_module_error(
                                    module_index=param[&#39;value&#39;][&#39;Module&#39;][&#39;index&#39;],
                                    error_index=param[&#39;value&#39;][&#39;Module&#39;][&#39;error&#39;]
                                )
                                self.__error_message = {
                                    &#39;type&#39;: &#39;Module&#39;,
                                    &#39;name&#39;: module_error.name,
                                    &#39;docs&#39;: module_error.docs
                                }
                            elif &#39;BadOrigin&#39; in param[&#39;value&#39;]:
                                self.__error_message = {
                                    &#39;type&#39;: &#39;System&#39;,
                                    &#39;name&#39;: &#39;BadOrigin&#39;,
                                    &#39;docs&#39;: &#39;Bad origin&#39;
                                }
                            elif &#39;CannotLookup&#39; in param[&#39;value&#39;]:
                                self.__error_message = {
                                    &#39;type&#39;: &#39;System&#39;,
                                    &#39;name&#39;: &#39;CannotLookup&#39;,
                                    &#39;docs&#39;: &#39;Cannot lookup&#39;
                                }
                            elif &#39;Other&#39; in param[&#39;value&#39;]:
                                self.__error_message = {
                                    &#39;type&#39;: &#39;System&#39;,
                                    &#39;name&#39;: &#39;Other&#39;,
                                    &#39;docs&#39;: &#39;Unspecified error occurred&#39;
                                }

                        if param[&#39;type&#39;] == &#39;DispatchInfo&#39;:
                            self.__weight = param[&#39;value&#39;][&#39;weight&#39;]

                if event.event_module.name == &#39;Treasury&#39; and event.event.name == &#39;Deposit&#39;:
                    self.__total_fee_amount += event.params[0][&#39;value&#39;]

                if event.event_module.name == &#39;Balances&#39; and event.event.name == &#39;Deposit&#39;:
                    self.__total_fee_amount += event.params[1][&#39;value&#39;]

    @property
    def is_success(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns `True` if `ExtrinsicSuccess` event is triggered, `False` in case of `ExtrinsicFailed`
        In case of False `error_message` will contain more details about the error


        Returns
        -------
        bool
        &#34;&#34;&#34;
        if self.__is_succes is None:
            self.process_events()

        return self.__is_succes

    @property
    def error_message(self) -&gt; typing.Optional[dict]:
        &#34;&#34;&#34;
        Returns the error message if the extrinsic failed in format e.g.:

        `{&#39;type&#39;: &#39;System&#39;, &#39;name&#39;: &#39;BadOrigin&#39;, &#39;docs&#39;: &#39;Bad origin&#39;}`

        Returns
        -------
        dict
        &#34;&#34;&#34;
        if self.__error_message is None:
            if self.is_success:
                return None
            self.process_events()
        return self.__error_message

    @property
    def weight(self) -&gt; int:
        &#34;&#34;&#34;
        Contains the actual weight when executing this extrinsic

        Returns
        -------
        int
        &#34;&#34;&#34;
        if self.__weight is None:
            self.process_events()
        return self.__weight

    @property
    def total_fee_amount(self) -&gt; int:
        &#34;&#34;&#34;
        Contains the total fee costs deducted when executing this extrinsic. This includes fee for the validator (
        (`Balances.Deposit` event) and the fee deposited for the treasury (`Treasury.Deposit` event)

        Returns
        -------
        int
        &#34;&#34;&#34;
        if self.__total_fee_amount is None:
            self.process_events()
        return self.__total_fee_amount

    # Helper functions
    @staticmethod
    def __get_extrinsic_index(block_extrinsics: list, extrinsic_hash: str) -&gt; int:
        &#34;&#34;&#34;
        Returns the index of a provided extrinsic
        &#34;&#34;&#34;
        for idx, extrinsic in enumerate(block_extrinsics):
            if extrinsic.extrinsic_hash == extrinsic_hash.replace(&#39;0x&#39;, &#39;&#39;):
                return idx
        raise ExtrinsicNotFound()

    # Backwards compatibility methods
    def __getitem__(self, item):
        return getattr(self, item)

    def __iter__(self):
        for item in self.__dict__.items():
            yield item

    def get(self, name):
        return self[name]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="substrateinterface.contracts.ContractExecutionReceipt" href="contracts.html#substrateinterface.contracts.ContractExecutionReceipt">ContractExecutionReceipt</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="substrateinterface.ExtrinsicReceipt.error_message"><code class="name">var <span class="ident">error_message</span> : Union[dict, NoneType]</code></dt>
<dd>
<div class="desc"><p>Returns the error message if the extrinsic failed in format e.g.:</p>
<p><code>{'type': 'System', 'name': 'BadOrigin', 'docs': 'Bad origin'}</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def error_message(self) -&gt; typing.Optional[dict]:
    &#34;&#34;&#34;
    Returns the error message if the extrinsic failed in format e.g.:

    `{&#39;type&#39;: &#39;System&#39;, &#39;name&#39;: &#39;BadOrigin&#39;, &#39;docs&#39;: &#39;Bad origin&#39;}`

    Returns
    -------
    dict
    &#34;&#34;&#34;
    if self.__error_message is None:
        if self.is_success:
            return None
        self.process_events()
    return self.__error_message</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.extrinsic"><code class="name">var <span class="ident">extrinsic</span> : scalecodec.block.Extrinsic</code></dt>
<dd>
<div class="desc"><p>Retrieves the <code>Extrinsic</code> subject of this receipt</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Extrinsic</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrinsic(self) -&gt; Extrinsic:
    &#34;&#34;&#34;
    Retrieves the `Extrinsic` subject of this receipt

    Returns
    -------
    Extrinsic
    &#34;&#34;&#34;
    if self.__extrinsic is None:
        self.retrieve_extrinsic()
    return self.__extrinsic</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.extrinsic_idx"><code class="name">var <span class="ident">extrinsic_idx</span> : int</code></dt>
<dd>
<div class="desc"><p>Retrieves the index of this extrinsic in containing block</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extrinsic_idx(self) -&gt; int:
    &#34;&#34;&#34;
    Retrieves the index of this extrinsic in containing block

    Returns
    -------
    int
    &#34;&#34;&#34;
    if self.__extrinsic_idx is None:
        self.retrieve_extrinsic()
    return self.__extrinsic_idx</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.is_succes"><code class="name">var <span class="ident">is_success</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if <code>ExtrinsicSuccess</code> event is triggered, <code>False</code> in case of <code>ExtrinsicFailed</code>
In case of False <code>error_message</code> will contain more details about the error</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_success(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns `True` if `ExtrinsicSuccess` event is triggered, `False` in case of `ExtrinsicFailed`
    In case of False `error_message` will contain more details about the error


    Returns
    -------
    bool
    &#34;&#34;&#34;
    if self.__is_succes is None:
        self.process_events()

    return self.__is_succes</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.total_fee_amount"><code class="name">var <span class="ident">total_fee_amount</span> : int</code></dt>
<dd>
<div class="desc"><p>Contains the total fee costs deducted when executing this extrinsic. This includes fee for the validator (
(<code>Balances.Deposit</code> event) and the fee deposited for the treasury (<code>Treasury.Deposit</code> event)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_fee_amount(self) -&gt; int:
    &#34;&#34;&#34;
    Contains the total fee costs deducted when executing this extrinsic. This includes fee for the validator (
    (`Balances.Deposit` event) and the fee deposited for the treasury (`Treasury.Deposit` event)

    Returns
    -------
    int
    &#34;&#34;&#34;
    if self.__total_fee_amount is None:
        self.process_events()
    return self.__total_fee_amount</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.triggered_events"><code class="name">var <span class="ident">triggered_events</span> : list</code></dt>
<dd>
<div class="desc"><p>Gets triggered events for submitted extrinsic. block_hash where extrinsic is included is required, manually
set block_hash or use <code>wait_for_inclusion</code> when submitting extrinsic</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def triggered_events(self) -&gt; list:
    &#34;&#34;&#34;
    Gets triggered events for submitted extrinsic. block_hash where extrinsic is included is required, manually
    set block_hash or use `wait_for_inclusion` when submitting extrinsic

    Returns
    -------
    list
    &#34;&#34;&#34;
    if self.__triggered_events is None:
        if not self.block_hash:
            raise ValueError(&#34;ExtrinsicReceipt can&#39;t retrieve events because it&#39;s unknown which block_hash it is &#34;
                             &#34;included, manually set block_hash or use `wait_for_inclusion` when sending extrinsic&#34;)

        if self.extrinsic_idx is None:
            self.retrieve_extrinsic()

        self.__triggered_events = []

        for event in self.substrate.get_events(block_hash=self.block_hash):
            if event.extrinsic_idx == self.extrinsic_idx:
                self.__triggered_events.append(event)

    return self.__triggered_events</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.weight"><code class="name">var <span class="ident">weight</span> : int</code></dt>
<dd>
<div class="desc"><p>Contains the actual weight when executing this extrinsic</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def weight(self) -&gt; int:
    &#34;&#34;&#34;
    Contains the actual weight when executing this extrinsic

    Returns
    -------
    int
    &#34;&#34;&#34;
    if self.__weight is None:
        self.process_events()
    return self.__weight</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.ExtrinsicReceipt.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name):
    return self[name]</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.process_events"><code class="name flex">
<span>def <span class="ident">process_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_events(self):
    if self.triggered_events:

        self.__total_fee_amount = 0

        for event in self.triggered_events:
            # Check events
            if event.event_module.name == &#39;System&#39; and event.event.name == &#39;ExtrinsicSuccess&#39;:
                self.__is_succes = True
                self.__error_message = None

                for param in event.params:
                    if param[&#39;type&#39;] == &#39;DispatchInfo&#39;:
                        self.__weight = param[&#39;value&#39;][&#39;weight&#39;]

            if event.event_module.name == &#39;System&#39; and event.event.name == &#39;ExtrinsicFailed&#39;:
                self.__is_succes = False

                for param in event.params:
                    if param[&#39;type&#39;] == &#39;DispatchError&#39;:
                        if &#39;Module&#39; in param[&#39;value&#39;]:
                            module_error = self.substrate.metadata_decoder.get_module_error(
                                module_index=param[&#39;value&#39;][&#39;Module&#39;][&#39;index&#39;],
                                error_index=param[&#39;value&#39;][&#39;Module&#39;][&#39;error&#39;]
                            )
                            self.__error_message = {
                                &#39;type&#39;: &#39;Module&#39;,
                                &#39;name&#39;: module_error.name,
                                &#39;docs&#39;: module_error.docs
                            }
                        elif &#39;BadOrigin&#39; in param[&#39;value&#39;]:
                            self.__error_message = {
                                &#39;type&#39;: &#39;System&#39;,
                                &#39;name&#39;: &#39;BadOrigin&#39;,
                                &#39;docs&#39;: &#39;Bad origin&#39;
                            }
                        elif &#39;CannotLookup&#39; in param[&#39;value&#39;]:
                            self.__error_message = {
                                &#39;type&#39;: &#39;System&#39;,
                                &#39;name&#39;: &#39;CannotLookup&#39;,
                                &#39;docs&#39;: &#39;Cannot lookup&#39;
                            }
                        elif &#39;Other&#39; in param[&#39;value&#39;]:
                            self.__error_message = {
                                &#39;type&#39;: &#39;System&#39;,
                                &#39;name&#39;: &#39;Other&#39;,
                                &#39;docs&#39;: &#39;Unspecified error occurred&#39;
                            }

                    if param[&#39;type&#39;] == &#39;DispatchInfo&#39;:
                        self.__weight = param[&#39;value&#39;][&#39;weight&#39;]

            if event.event_module.name == &#39;Treasury&#39; and event.event.name == &#39;Deposit&#39;:
                self.__total_fee_amount += event.params[0][&#39;value&#39;]

            if event.event_module.name == &#39;Balances&#39; and event.event.name == &#39;Deposit&#39;:
                self.__total_fee_amount += event.params[1][&#39;value&#39;]</code></pre>
</details>
</dd>
<dt id="substrateinterface.ExtrinsicReceipt.retrieve_extrinsic"><code class="name flex">
<span>def <span class="ident">retrieve_extrinsic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_extrinsic(self):
    if not self.block_hash:
        raise ValueError(&#34;ExtrinsicReceipt can&#39;t retrieve events because it&#39;s unknown which block_hash it is &#34;
                         &#34;included, manually set block_hash or use `wait_for_inclusion` when sending extrinsic&#34;)
    # Determine extrinsic idx

    extrinsics = self.substrate.get_block_extrinsics(block_hash=self.block_hash)

    if len(extrinsics) &gt; 0:
        self.__extrinsic_idx = self.__get_extrinsic_index(
            block_extrinsics=extrinsics,
            extrinsic_hash=self.extrinsic_hash
        )

        self.__extrinsic = extrinsics[self.__extrinsic_idx]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="substrateinterface.Keypair"><code class="flex name class">
<span>class <span class="ident">Keypair</span></span>
<span>(</span><span>ss58_address=None, public_key=None, private_key=None, ss58_format=42, address_type=None, seed_hex=None, crypto_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows generation of Keypairs from a variety of input combination, such as a public/private key combination, a
mnemonic or a uri containing soft and hard derivation paths. With these Keypairs data can be signed and verified</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ss58_address</code></strong> :&ensp;<code>Substrate address</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>public_key</code></strong> :&ensp;<code>hex string</code> or <code>bytes</code> of <code>public_key <a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>private_key</code></strong> :&ensp;<code>hex string</code> or <code>bytes</code> of <code>private <a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>Substrate address format</code>, default <code>= 42</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>address_type</code></strong> :&ensp;<code>(deprecated) replaced by ss58_format</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>seed_hex</code></strong> :&ensp;<code>hex string</code> of <code>seed</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>crypto_type</code></strong> :&ensp;<code>Use <a title="substrateinterface.KeypairType.SR25519" href="#substrateinterface.KeypairType.SR25519">KeypairType.SR25519</a></code> or <code><a title="substrateinterface.KeypairType.ED25519" href="#substrateinterface.KeypairType.ED25519">KeypairType.ED25519</a> cryptography for generating the <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Keypair:

    def __init__(self, ss58_address=None, public_key=None, private_key=None, ss58_format=42,
                 address_type=None, seed_hex=None,
                 crypto_type=KeypairType.SR25519):
        &#34;&#34;&#34;
        Allows generation of Keypairs from a variety of input combination, such as a public/private key combination, a
        mnemonic or a uri containing soft and hard derivation paths. With these Keypairs data can be signed and verified

        Parameters
        ----------
        ss58_address: Substrate address
        public_key: hex string or bytes of public_key key
        private_key: hex string or bytes of private key
        ss58_format: Substrate address format, default = 42
        address_type: (deprecated) replaced by ss58_format
        seed_hex: hex string of seed
        crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair
        &#34;&#34;&#34;

        self.crypto_type = crypto_type
        self.seed_hex = seed_hex
        self.derive_path = None

        if ss58_address and not public_key:
            public_key = ss58_decode(ss58_address)

        if not public_key:
            raise ValueError(&#39;No SS58 formatted address or public key provided&#39;)

        if type(public_key) is bytes:
            public_key = public_key.hex()

        public_key = &#39;0x{}&#39;.format(public_key.replace(&#39;0x&#39;, &#39;&#39;))

        if len(public_key) != 66:
            raise ValueError(&#39;Public key should be 32 bytes long&#39;)

        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        self.ss58_format = ss58_format

        if not ss58_address:
            ss58_address = ss58_encode(public_key, ss58_format=ss58_format)

        self.public_key = public_key

        self.ss58_address = ss58_address

        if private_key:

            if type(private_key) is bytes:
                private_key = private_key.hex()

            private_key = &#39;0x{}&#39;.format(private_key.replace(&#39;0x&#39;, &#39;&#39;))

            if self.crypto_type == KeypairType.SR25519 and len(private_key) != 130:
                raise ValueError(&#39;Secret key should be 64 bytes long&#39;)

        self.private_key = private_key

        self.mnemonic = None

    @classmethod
    def generate_mnemonic(cls, words=12):
        &#34;&#34;&#34;
        Generates a new seed phrase with given amount of words (default 12)

        Parameters
        ----------
        words: The amount of words to generate, valid values are 12, 15, 18, 21 and 24

        Returns
        -------
        Seed phrase
        &#34;&#34;&#34;
        return bip39_generate(words)

    @classmethod
    def create_from_mnemonic(cls, mnemonic, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
        &#34;&#34;&#34;
        Create a Keypair for given memonic

        Parameters
        ----------
        mnemonic: Seed phrase
        ss58_format: Substrate address format, default = 42
        address_type: (deprecated)
        crypto_type: Use `KeypairType.SR25519` or `KeypairType.ED25519` cryptography for generating the Keypair

        Returns
        -------
        Keypair
        &#34;&#34;&#34;
        seed_array = bip39_to_mini_secret(mnemonic, &#34;&#34;)

        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        keypair = cls.create_from_seed(
            seed_hex=binascii.hexlify(bytearray(seed_array)).decode(&#34;ascii&#34;),
            ss58_format=ss58_format,
            crypto_type=crypto_type
        )
        keypair.mnemonic = mnemonic

        return keypair

    @classmethod
    def create_from_seed(cls, seed_hex, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
        &#34;&#34;&#34;
        Create a Keypair for given seed

        Parameters
        ----------
        seed_hex: hex string of seed
        ss58_format: Substrate address format, default = 42
        address_type: (deprecated)
        crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

        Returns
        -------
        Keypair
        &#34;&#34;&#34;

        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        if crypto_type == KeypairType.SR25519:
            public_key, private_key = sr25519.pair_from_seed(bytes.fromhex(seed_hex.replace(&#39;0x&#39;, &#39;&#39;)))
        elif crypto_type == KeypairType.ED25519:
            private_key, public_key = ed25519.ed_from_seed(bytes.fromhex(seed_hex.replace(&#39;0x&#39;, &#39;&#39;)))
        else:
            raise ValueError(&#39;crypto_type &#34;{}&#34; not supported&#39;.format(crypto_type))

        public_key = public_key.hex()
        private_key = private_key.hex()

        ss58_address = ss58_encode(public_key, ss58_format)

        return cls(
            ss58_address=ss58_address, public_key=public_key, private_key=private_key,
            ss58_format=ss58_format, crypto_type=crypto_type, seed_hex=seed_hex
        )

    @classmethod
    def create_from_uri(cls, suri, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
        &#34;&#34;&#34;
        Creates Keypair for specified suri in following format: `&lt;mnemonic&gt;/&lt;soft-path&gt;//&lt;hard-path&gt;`

        Parameters
        ----------
        suri:
        ss58_format: Substrate address format, default = 42
        address_type: (deprecated)
        crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

        Returns
        -------
        Keypair
        &#34;&#34;&#34;

        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        if suri and suri.startswith(&#39;/&#39;):
            suri = DEV_PHRASE + suri

        suri_regex = re.match(r&#39;^(?P&lt;phrase&gt;\w+( \w+)*)(?P&lt;path&gt;(//?[^/]+)*)(///(?P&lt;password&gt;.*))?$&#39;, suri)

        suri_parts = suri_regex.groupdict()

        if suri_parts[&#39;password&#39;]:
            raise NotImplementedError(&#34;Passwords in suri not supported&#34;)

        derived_keypair = cls.create_from_mnemonic(
            suri_parts[&#39;phrase&#39;], ss58_format=ss58_format, crypto_type=crypto_type
        )

        if suri_parts[&#39;path&#39;] != &#39;&#39;:

            derived_keypair.derive_path = suri_parts[&#39;path&#39;]

            if crypto_type not in [KeypairType.SR25519]:
                raise NotImplementedError(&#39;Derivation paths for this crypto type not supported&#39;)

            derive_junctions = extract_derive_path(suri_parts[&#39;path&#39;])

            child_pubkey = bytes.fromhex(derived_keypair.public_key[2:])
            child_privkey = bytes.fromhex(derived_keypair.private_key[2:])

            for junction in derive_junctions:

                if junction.is_hard:

                    _, child_pubkey, child_privkey = sr25519.hard_derive_keypair(
                        (junction.chain_code, child_pubkey, child_privkey),
                        b&#39;&#39;
                    )

                else:

                    _, child_pubkey, child_privkey = sr25519.derive_keypair(
                        (junction.chain_code, child_pubkey, child_privkey),
                        b&#39;&#39;
                    )

            derived_keypair = Keypair(public_key=child_pubkey, private_key=child_privkey, ss58_format=ss58_format)

        return derived_keypair

    @classmethod
    def create_from_private_key(
            cls, private_key, public_key=None, ss58_address=None, ss58_format=42, crypto_type=KeypairType.SR25519,
            address_type=None
    ):
        &#34;&#34;&#34;
        Creates Keypair for specified public/private keys
        Parameters
        ----------
        private_key: hex string or bytes of private key
        public_key: hex string or bytes of public key
        ss58_address: Substrate address
        ss58_format: Substrate address format, default = 42
        address_type: (deprecated)
        crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

        Returns
        -------
        Keypair
        &#34;&#34;&#34;
        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        return cls(
            ss58_address=ss58_address, public_key=public_key, private_key=private_key,
            ss58_format=ss58_format, crypto_type=crypto_type
        )

    def sign(self, data):
        &#34;&#34;&#34;
        Creates a signature for given data

        Parameters
        ----------
        data: data to sign in `Scalebytes`, bytes or hex string format

        Returns
        -------
        signature in hex string format

        &#34;&#34;&#34;
        if type(data) is ScaleBytes:
            data = bytes(data.data)
        elif data[0:2] == &#39;0x&#39;:
            data = bytes.fromhex(data[2:])
        else:
            data = data.encode()

        if not self.private_key:
            raise ConfigurationError(&#39;No private key set to create signatures&#39;)

        if self.crypto_type == KeypairType.SR25519:

            signature = sr25519.sign((bytes.fromhex(self.public_key[2:]), bytes.fromhex(self.private_key[2:])), data)
        elif self.crypto_type == KeypairType.ED25519:
            signature = ed25519.ed_sign(bytes.fromhex(self.public_key[2:]), bytes.fromhex(self.private_key[2:]), data)
        else:
            raise ConfigurationError(&#34;Crypto type not supported&#34;)

        return &#34;0x{}&#34;.format(signature.hex())

    def verify(self, data, signature):
        &#34;&#34;&#34;
        Verifies data with specified signature

        Parameters
        ----------
        data: data to be verified in `Scalebytes`, bytes or hex string format
        signature: signature in bytes or hex string format

        Returns
        -------
        True if data is signed with this Keypair, otherwise False
        &#34;&#34;&#34;

        if type(data) is ScaleBytes:
            data = bytes(data.data)
        elif data[0:2] == &#39;0x&#39;:
            data = bytes.fromhex(data[2:])
        else:
            data = data.encode()

        if type(signature) is str and signature[0:2] == &#39;0x&#39;:
            signature = bytes.fromhex(signature[2:])

        if type(signature) is not bytes:
            raise TypeError(&#34;Signature should be of type bytes or a hex-string&#34;)

        if self.crypto_type == KeypairType.SR25519:
            return sr25519.verify(signature, data, bytes.fromhex(self.public_key[2:]))
        elif self.crypto_type == KeypairType.ED25519:
            return ed25519.ed_verify(signature, data, bytes.fromhex(self.public_key[2:]))
        else:
            raise ConfigurationError(&#34;Crypto type not supported&#34;)

    def __repr__(self):
        return &#39;&lt;Keypair (ss58_address={})&gt;&#39;.format(self.ss58_address)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="substrateinterface.Keypair.create_from_mnemonic"><code class="name flex">
<span>def <span class="ident">create_from_mnemonic</span></span>(<span>mnemonic, ss58_format=42, address_type=None, crypto_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Keypair for given memonic</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mnemonic</code></strong> :&ensp;<code>Seed phrase</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>Substrate address format</code>, default <code>= 42</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>address_type</code></strong> :&ensp;<code>(deprecated)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>crypto_type</code></strong> :&ensp;<code>Use </code>KeypairType.SR25519<code> or </code>KeypairType.ED25519<code> cryptography for generating the <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_mnemonic(cls, mnemonic, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
    &#34;&#34;&#34;
    Create a Keypair for given memonic

    Parameters
    ----------
    mnemonic: Seed phrase
    ss58_format: Substrate address format, default = 42
    address_type: (deprecated)
    crypto_type: Use `KeypairType.SR25519` or `KeypairType.ED25519` cryptography for generating the Keypair

    Returns
    -------
    Keypair
    &#34;&#34;&#34;
    seed_array = bip39_to_mini_secret(mnemonic, &#34;&#34;)

    if address_type is not None:
        warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
        ss58_format = address_type

    keypair = cls.create_from_seed(
        seed_hex=binascii.hexlify(bytearray(seed_array)).decode(&#34;ascii&#34;),
        ss58_format=ss58_format,
        crypto_type=crypto_type
    )
    keypair.mnemonic = mnemonic

    return keypair</code></pre>
</details>
</dd>
<dt id="substrateinterface.Keypair.create_from_private_key"><code class="name flex">
<span>def <span class="ident">create_from_private_key</span></span>(<span>private_key, public_key=None, ss58_address=None, ss58_format=42, crypto_type=1, address_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Keypair for specified public/private keys
Parameters</p>
<hr>
<dl>
<dt><strong><code>private_key</code></strong> :&ensp;<code>hex string</code> or <code>bytes</code> of <code>private <a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>public_key</code></strong> :&ensp;<code>hex string</code> or <code>bytes</code> of <code>public <a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_address</code></strong> :&ensp;<code>Substrate address</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>Substrate address format</code>, default <code>= 42</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>address_type</code></strong> :&ensp;<code>(deprecated)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>crypto_type</code></strong> :&ensp;<code>Use <a title="substrateinterface.KeypairType.SR25519" href="#substrateinterface.KeypairType.SR25519">KeypairType.SR25519</a></code> or <code><a title="substrateinterface.KeypairType.ED25519" href="#substrateinterface.KeypairType.ED25519">KeypairType.ED25519</a> cryptography for generating the <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_private_key(
        cls, private_key, public_key=None, ss58_address=None, ss58_format=42, crypto_type=KeypairType.SR25519,
        address_type=None
):
    &#34;&#34;&#34;
    Creates Keypair for specified public/private keys
    Parameters
    ----------
    private_key: hex string or bytes of private key
    public_key: hex string or bytes of public key
    ss58_address: Substrate address
    ss58_format: Substrate address format, default = 42
    address_type: (deprecated)
    crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

    Returns
    -------
    Keypair
    &#34;&#34;&#34;
    if address_type is not None:
        warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
        ss58_format = address_type

    return cls(
        ss58_address=ss58_address, public_key=public_key, private_key=private_key,
        ss58_format=ss58_format, crypto_type=crypto_type
    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.Keypair.create_from_seed"><code class="name flex">
<span>def <span class="ident">create_from_seed</span></span>(<span>seed_hex, ss58_format=42, address_type=None, crypto_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Keypair for given seed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seed_hex</code></strong> :&ensp;<code>hex string</code> of <code>seed</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>Substrate address format</code>, default <code>= 42</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>address_type</code></strong> :&ensp;<code>(deprecated)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>crypto_type</code></strong> :&ensp;<code>Use <a title="substrateinterface.KeypairType.SR25519" href="#substrateinterface.KeypairType.SR25519">KeypairType.SR25519</a></code> or <code><a title="substrateinterface.KeypairType.ED25519" href="#substrateinterface.KeypairType.ED25519">KeypairType.ED25519</a> cryptography for generating the <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_seed(cls, seed_hex, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
    &#34;&#34;&#34;
    Create a Keypair for given seed

    Parameters
    ----------
    seed_hex: hex string of seed
    ss58_format: Substrate address format, default = 42
    address_type: (deprecated)
    crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

    Returns
    -------
    Keypair
    &#34;&#34;&#34;

    if address_type is not None:
        warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
        ss58_format = address_type

    if crypto_type == KeypairType.SR25519:
        public_key, private_key = sr25519.pair_from_seed(bytes.fromhex(seed_hex.replace(&#39;0x&#39;, &#39;&#39;)))
    elif crypto_type == KeypairType.ED25519:
        private_key, public_key = ed25519.ed_from_seed(bytes.fromhex(seed_hex.replace(&#39;0x&#39;, &#39;&#39;)))
    else:
        raise ValueError(&#39;crypto_type &#34;{}&#34; not supported&#39;.format(crypto_type))

    public_key = public_key.hex()
    private_key = private_key.hex()

    ss58_address = ss58_encode(public_key, ss58_format)

    return cls(
        ss58_address=ss58_address, public_key=public_key, private_key=private_key,
        ss58_format=ss58_format, crypto_type=crypto_type, seed_hex=seed_hex
    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.Keypair.create_from_uri"><code class="name flex">
<span>def <span class="ident">create_from_uri</span></span>(<span>suri, ss58_format=42, address_type=None, crypto_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Keypair for specified suri in following format: <code>&lt;mnemonic&gt;/&lt;soft-path&gt;//&lt;hard-path&gt;</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>suri:</dt>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>Substrate address format</code>, default <code>= 42</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>address_type</code></strong> :&ensp;<code>(deprecated)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>crypto_type</code></strong> :&ensp;<code>Use <a title="substrateinterface.KeypairType.SR25519" href="#substrateinterface.KeypairType.SR25519">KeypairType.SR25519</a></code> or <code><a title="substrateinterface.KeypairType.ED25519" href="#substrateinterface.KeypairType.ED25519">KeypairType.ED25519</a> cryptography for generating the <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_uri(cls, suri, ss58_format=42, address_type=None, crypto_type=KeypairType.SR25519):
    &#34;&#34;&#34;
    Creates Keypair for specified suri in following format: `&lt;mnemonic&gt;/&lt;soft-path&gt;//&lt;hard-path&gt;`

    Parameters
    ----------
    suri:
    ss58_format: Substrate address format, default = 42
    address_type: (deprecated)
    crypto_type: Use KeypairType.SR25519 or KeypairType.ED25519 cryptography for generating the Keypair

    Returns
    -------
    Keypair
    &#34;&#34;&#34;

    if address_type is not None:
        warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
        ss58_format = address_type

    if suri and suri.startswith(&#39;/&#39;):
        suri = DEV_PHRASE + suri

    suri_regex = re.match(r&#39;^(?P&lt;phrase&gt;\w+( \w+)*)(?P&lt;path&gt;(//?[^/]+)*)(///(?P&lt;password&gt;.*))?$&#39;, suri)

    suri_parts = suri_regex.groupdict()

    if suri_parts[&#39;password&#39;]:
        raise NotImplementedError(&#34;Passwords in suri not supported&#34;)

    derived_keypair = cls.create_from_mnemonic(
        suri_parts[&#39;phrase&#39;], ss58_format=ss58_format, crypto_type=crypto_type
    )

    if suri_parts[&#39;path&#39;] != &#39;&#39;:

        derived_keypair.derive_path = suri_parts[&#39;path&#39;]

        if crypto_type not in [KeypairType.SR25519]:
            raise NotImplementedError(&#39;Derivation paths for this crypto type not supported&#39;)

        derive_junctions = extract_derive_path(suri_parts[&#39;path&#39;])

        child_pubkey = bytes.fromhex(derived_keypair.public_key[2:])
        child_privkey = bytes.fromhex(derived_keypair.private_key[2:])

        for junction in derive_junctions:

            if junction.is_hard:

                _, child_pubkey, child_privkey = sr25519.hard_derive_keypair(
                    (junction.chain_code, child_pubkey, child_privkey),
                    b&#39;&#39;
                )

            else:

                _, child_pubkey, child_privkey = sr25519.derive_keypair(
                    (junction.chain_code, child_pubkey, child_privkey),
                    b&#39;&#39;
                )

        derived_keypair = Keypair(public_key=child_pubkey, private_key=child_privkey, ss58_format=ss58_format)

    return derived_keypair</code></pre>
</details>
</dd>
<dt id="substrateinterface.Keypair.generate_mnemonic"><code class="name flex">
<span>def <span class="ident">generate_mnemonic</span></span>(<span>words=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new seed phrase with given amount of words (default 12)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>words</code></strong> :&ensp;<code>The amount</code> of <code>words to generate, valid values are 12, 15, 18, 21 and 24</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Seed phrase</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_mnemonic(cls, words=12):
    &#34;&#34;&#34;
    Generates a new seed phrase with given amount of words (default 12)

    Parameters
    ----------
    words: The amount of words to generate, valid values are 12, 15, 18, 21 and 24

    Returns
    -------
    Seed phrase
    &#34;&#34;&#34;
    return bip39_generate(words)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.Keypair.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a signature for given data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>data to sign in </code>Scalebytes<code>, bytes</code> or <code>hex string format</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>signature in hex string format</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, data):
    &#34;&#34;&#34;
    Creates a signature for given data

    Parameters
    ----------
    data: data to sign in `Scalebytes`, bytes or hex string format

    Returns
    -------
    signature in hex string format

    &#34;&#34;&#34;
    if type(data) is ScaleBytes:
        data = bytes(data.data)
    elif data[0:2] == &#39;0x&#39;:
        data = bytes.fromhex(data[2:])
    else:
        data = data.encode()

    if not self.private_key:
        raise ConfigurationError(&#39;No private key set to create signatures&#39;)

    if self.crypto_type == KeypairType.SR25519:

        signature = sr25519.sign((bytes.fromhex(self.public_key[2:]), bytes.fromhex(self.private_key[2:])), data)
    elif self.crypto_type == KeypairType.ED25519:
        signature = ed25519.ed_sign(bytes.fromhex(self.public_key[2:]), bytes.fromhex(self.private_key[2:]), data)
    else:
        raise ConfigurationError(&#34;Crypto type not supported&#34;)

    return &#34;0x{}&#34;.format(signature.hex())</code></pre>
</details>
</dd>
<dt id="substrateinterface.Keypair.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, data, signature)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies data with specified signature</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>data to be verified in </code>Scalebytes<code>, bytes</code> or <code>hex string format</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>signature</code></strong> :&ensp;<code>signature in bytes</code> or <code>hex string format</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True if data is signed with this <a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a>, otherwise False</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify(self, data, signature):
    &#34;&#34;&#34;
    Verifies data with specified signature

    Parameters
    ----------
    data: data to be verified in `Scalebytes`, bytes or hex string format
    signature: signature in bytes or hex string format

    Returns
    -------
    True if data is signed with this Keypair, otherwise False
    &#34;&#34;&#34;

    if type(data) is ScaleBytes:
        data = bytes(data.data)
    elif data[0:2] == &#39;0x&#39;:
        data = bytes.fromhex(data[2:])
    else:
        data = data.encode()

    if type(signature) is str and signature[0:2] == &#39;0x&#39;:
        signature = bytes.fromhex(signature[2:])

    if type(signature) is not bytes:
        raise TypeError(&#34;Signature should be of type bytes or a hex-string&#34;)

    if self.crypto_type == KeypairType.SR25519:
        return sr25519.verify(signature, data, bytes.fromhex(self.public_key[2:]))
    elif self.crypto_type == KeypairType.ED25519:
        return ed25519.ed_verify(signature, data, bytes.fromhex(self.public_key[2:]))
    else:
        raise ConfigurationError(&#34;Crypto type not supported&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="substrateinterface.KeypairType"><code class="flex name class">
<span>class <span class="ident">KeypairType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeypairType:
    ED25519 = 0
    SR25519 = 1</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="substrateinterface.KeypairType.ED25519"><code class="name">var <span class="ident">ED25519</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="substrateinterface.KeypairType.SR25519"><code class="name">var <span class="ident">SR25519</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="substrateinterface.SubstrateInterface"><code class="flex name class">
<span>class <span class="ident">SubstrateInterface</span></span>
<span>(</span><span>url=None, websocket=None, ss58_format=None, type_registry=None, type_registry_preset=None, cache_region=None, address_type=None, runtime_config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A specialized class in interfacing with a Substrate node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>the URL to the substrate node, either in format &lt;https://127.0.0.1:9933&gt;</code> or <code>wss://127.0.0.1:9944</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ss58_format</code></strong> :&ensp;<code>The address type which account IDs will be SS58-encoded to Substrate addresses. Defaults to 42, for Kusama the address type is 2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>type_registry</code></strong> :&ensp;<code>A dict containing the custom type registry in format: {'types': {'customType': 'u32'},..}</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>type_registry_preset</code></strong> :&ensp;<code>The name</code> of <code>the predefined type registry shipped with the SCALE-codec, e.g. kusama</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cache_region</code></strong> :&ensp;<code>a Dogpile cache region as a central store for the metadata cache</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubstrateInterface:

    def __init__(self, url=None, websocket=None, ss58_format=None, type_registry=None, type_registry_preset=None,
                 cache_region=None, address_type=None, runtime_config=None):
        &#34;&#34;&#34;
        A specialized class in interfacing with a Substrate node.

        Parameters
        ----------
        url: the URL to the substrate node, either in format https://127.0.0.1:9933 or wss://127.0.0.1:9944
        ss58_format: The address type which account IDs will be SS58-encoded to Substrate addresses. Defaults to 42, for Kusama the address type is 2
        type_registry: A dict containing the custom type registry in format: {&#39;types&#39;: {&#39;customType&#39;: &#39;u32&#39;},..}
        type_registry_preset: The name of the predefined type registry shipped with the SCALE-codec, e.g. kusama
        cache_region: a Dogpile cache region as a central store for the metadata cache
        &#34;&#34;&#34;

        if (not url and not websocket) or (url and websocket):
            raise ValueError(&#34;Either &#39;url&#39; or &#39;websocket&#39; must be provided&#34;)

        if address_type is not None:
            warnings.warn(&#34;Keyword &#39;address_type&#39; will be replaced by &#39;ss58_format&#39;&#34;, DeprecationWarning)
            ss58_format = address_type

        # Initialize lazy loading variables
        self.__version = None
        self.__name = None
        self.__properties = None
        self.__chain = None

        self.__token_decimals = None
        self.__token_symbol = None
        self.__ss58_format = None

        self.cache_region = cache_region

        self.ss58_format = ss58_format

        self.request_id = 1
        self.url = url
        self.websocket = None

        if self.url and (self.url[0:6] == &#39;wss://&#39; or self.url[0:5] == &#39;ws://&#39;):
            self.connect_websocket()

        elif websocket:
            self.websocket = websocket

        self.mock_extrinsics = None
        self.default_headers = {
            &#39;content-type&#39;: &#34;application/json&#34;,
            &#39;cache-control&#39;: &#34;no-cache&#34;
        }

        self.metadata_decoder = None

        self.runtime_version = None
        self.transaction_version = None

        self.block_hash = None
        self.block_id = None

        self.metadata_cache = {}
        self.type_registry_cache = {}

        if not runtime_config:
            runtime_config = RuntimeConfigurationObject()

        self.runtime_config = runtime_config

        self.debug = False

        if type_registry_preset:
            # Load type registry according to preset
            type_registry_preset_dict = load_type_registry_preset(type_registry_preset)

            if not type_registry_preset_dict:
                raise ValueError(f&#34;Type registry preset &#39;{type_registry_preset}&#39; not found&#34;)
        else:
            # Try to auto discover type registry preset by chain name
            type_registry_preset_dict = load_type_registry_preset(self.chain.lower())

            if not type_registry_preset_dict:
                raise ValueError(f&#34;Could not auto-detect type registry preset for chain &#39;{self.chain}&#39;&#34;)

            self.debug_message(f&#34;Auto set type_registry_preset to {self.chain.lower()} ...&#34;)

        if type_registry_preset_dict:
            # Load type registries in runtime configuration
            self.runtime_config.update_type_registry(load_type_registry_preset(&#34;default&#34;))

            if type_registry_preset != &#34;default&#34;:
                self.runtime_config.update_type_registry(type_registry_preset_dict)

        if type_registry:
            # Load type registries in runtime configuration
            self.runtime_config.update_type_registry(type_registry)

    def connect_websocket(self):
        if self.url and (self.url[0:6] == &#39;wss://&#39; or self.url[0:5] == &#39;ws://&#39;):
            self.debug_message(&#34;Connecting to {} ...&#34;.format(self.url))
            self.websocket = create_connection(
                self.url,
                max_size=2 ** 32,
                read_limit=2 ** 32,
                write_limit=2 ** 32,
            )

    def debug_message(self, message):
        logger.debug(message)

    def rpc_request(self, method, params, result_handler=None):
        &#34;&#34;&#34;
        Method that handles the actual RPC request to the Substrate node. The other implemented functions eventually
        use this method to perform the request.

        Parameters
        ----------
        result_handler: Callback of function that processes the result received from the node
        method: method of the JSONRPC request
        params: a list containing the parameters of the JSONRPC request

        Returns
        -------
        a dict with the parsed result of the request.
        &#34;&#34;&#34;
        payload = {
            &#34;jsonrpc&#34;: &#34;2.0&#34;,
            &#34;method&#34;: method,
            &#34;params&#34;: params,
            &#34;id&#34;: self.request_id
        }

        self.debug_message(&#39;RPC request #{}: &#34;{}&#34;&#39;.format(self.request_id, method))

        if self.websocket:
            try:
                self.websocket.send(json.dumps(payload))

                if callable(result_handler):
                    # If result handler is set, pass result through and loop until handler return not None
                    event_number = 0
                    json_body = None
                    while not json_body:
                        result = json.loads(self.websocket.recv())
                        self.debug_message(&#34;Websocket result [{}] Received from node: {}&#34;.format(event_number, result))

                        # Check if response has error
                        if &#39;error&#39; in result:
                            raise SubstrateRequestException(result[&#39;error&#39;])

                        callback_result = result_handler(result)
                        if callback_result:
                            json_body = callback_result

                        event_number += 1
                else:

                    json_body = json.loads(self.websocket.recv())

            except WebSocketConnectionClosedException:
                if self.url:
                    # Try to reconnect websocket and retry rpc_request
                    self.debug_message(&#34;Connection Closed; Trying to reconnecting...&#34;)
                    self.connect_websocket()

                    return self.rpc_request(method=method, params=params, result_handler=result_handler)
                else:
                    # websocket connection is externally created, re-raise exception
                    raise

        else:

            if result_handler:
                raise ConfigurationError(&#34;Result handlers only available for websockets (ws://) connections&#34;)

            response = requests.request(&#34;POST&#34;, self.url, data=json.dumps(payload), headers=self.default_headers)

            if response.status_code != 200:
                raise SubstrateRequestException(&#34;RPC request failed with HTTP status code {}&#34;.format(response.status_code))

            json_body = response.json()

        self.request_id += 1
        return json_body

    @property
    def name(self):
        if self.__name is None:
            self.__name = self.rpc_request(&#34;system_name&#34;, []).get(&#39;result&#39;)
        return self.__name

    @property
    def properties(self):
        if self.__properties is None:
            self.__properties = self.rpc_request(&#34;system_properties&#34;, []).get(&#39;result&#39;)
        return self.__properties

    @property
    def chain(self):
        if self.__chain is None:
            self.__chain = self.rpc_request(&#34;system_chain&#34;, []).get(&#39;result&#39;)
        return self.__chain

    @property
    def version(self):
        if self.__version is None:
            self.__version = self.rpc_request(&#34;system_version&#34;, []).get(&#39;result&#39;)
        return self.__version

    @property
    def token_decimals(self):
        if self.__token_decimals is None:
            self.__token_decimals = self.properties.get(&#39;tokenDecimals&#39;)
        return self.__token_decimals

    @token_decimals.setter
    def token_decimals(self, value):
        if type(value) is not int and value is not None:
            raise TypeError(&#39;Token decimals must be an int&#39;)
        self.__token_decimals = value

    @property
    def token_symbol(self):
        if self.__token_symbol is None:
            if self.properties:
                self.__token_symbol = self.properties.get(&#39;tokenSymbol&#39;)
            else:
                self.__token_symbol = &#39;UNIT&#39;
        return self.__token_symbol

    @token_symbol.setter
    def token_symbol(self, value):
        self.__token_symbol = value

    @property
    def ss58_format(self):
        if self.__ss58_format is None:
            if self.properties:
                self.__ss58_format = self.properties.get(&#39;ss58Format&#39;)
            else:
                self.__ss58_format = 42
        return self.__ss58_format

    @ss58_format.setter
    def ss58_format(self, value):
        if type(value) is not int and value is not None:
            raise TypeError(&#39;ss58_format must be an int&#39;)
        self.__ss58_format = value

    def get_chain_head(self):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `chain_getHead`

        Returns
        -------

        &#34;&#34;&#34;
        response = self.rpc_request(&#34;chain_getHead&#34;, [])
        return response.get(&#39;result&#39;)

    def get_chain_finalised_head(self):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `chain_getFinalisedHead`

        Returns
        -------

        &#34;&#34;&#34;
        response = self.rpc_request(&#34;chain_getFinalisedHead&#34;, [])
        return response.get(&#39;result&#39;)

    def get_chain_block(self, block_hash=None, block_id=None, metadata_decoder=None):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `chain_getBlock`. For a decoded version see `get_runtime_block()`

        Parameters
        ----------
        block_hash
        block_id
        metadata_decoder

        Returns
        -------

        &#34;&#34;&#34;

        if block_id:
            block_hash = self.get_block_hash(block_id)

        response = self.rpc_request(&#34;chain_getBlock&#34;, [block_hash]).get(&#39;result&#39;)

        if self.mock_extrinsics:
            # Extend extrinsics with mock_extrinsics for e.g. performance tests
            response[&#39;block&#39;][&#39;extrinsics&#39;].extend(self.mock_extrinsics)

        # Decode extrinsics
        if metadata_decoder:

            response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;] = int(response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;], 16)

            for idx, extrinsic_data in enumerate(response[&#39;block&#39;][&#39;extrinsics&#39;]):
                extrinsic_decoder = ExtrinsicsDecoder(
                    data=ScaleBytes(extrinsic_data),
                    metadata=metadata_decoder,
                    runtime_config=self.runtime_config
                )
                extrinsic_decoder.decode()
                response[&#39;block&#39;][&#39;extrinsics&#39;][idx] = extrinsic_decoder.value

            for idx, log_data in enumerate(response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;]):
                log_digest = LogDigest(ScaleBytes(log_data), runtime_config=self.runtime_config)
                log_digest.decode()
                response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;][idx] = log_digest.value

        return response

    def get_block_hash(self, block_id):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `chain_getBlockHash`

        Parameters
        ----------
        block_id

        Returns
        -------

        &#34;&#34;&#34;
        return self.rpc_request(&#34;chain_getBlockHash&#34;, [block_id]).get(&#39;result&#39;)

    def get_block_header(self, block_hash):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `chain_getHeader`

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        response = self.rpc_request(&#34;chain_getHeader&#34;, [block_hash])
        return response.get(&#39;result&#39;)

    def get_block_number(self, block_hash):
        &#34;&#34;&#34;
        A convenience method to get the block number for given block_hash

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        response = self.rpc_request(&#34;chain_getHeader&#34;, [block_hash])
        return int(response[&#39;result&#39;][&#39;number&#39;], 16)

    def get_block_metadata(self, block_hash=None, decode=True):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `state_getMetadata`. For a decoded version see `get_runtime_metadata()`

        Parameters
        ----------
        block_hash
        decode: DEPRECATED use `get_runtime_metadata()` for decoded version

        Returns
        -------

        &#34;&#34;&#34;
        params = None
        if block_hash:
            params = [block_hash]
        response = self.rpc_request(&#34;state_getMetadata&#34;, params)

        if decode:
            metadata_decoder = MetadataDecoder(ScaleBytes(response.get(&#39;result&#39;)))
            metadata_decoder.decode()

            return metadata_decoder

        return response

    def get_storage(self, block_hash, module, function, params=None, return_scale_type=None, hasher=None,
                    spec_version_id=&#39;default&#39;, metadata=None, metadata_version=None):
        &#34;&#34;&#34;
        Retrieves the storage entry for given module, function and optional parameters at given block.

        DEPRECATED: use `get_runtime_state()`

        Parameters
        ----------
        block_hash
        module
        function
        params
        return_scale_type: Scale type string to interprete result
        hasher: Hashing method used to determine storage key, defaults to &#39;Twox64Concat&#39; if not provided
        spec_version_id: DEPRECATED
        metadata
        metadata_version: Version index of Metadata, e.g. 9 for MetadataV9

        Returns
        -------

        &#34;&#34;&#34;
        storage_hash = self.generate_storage_hash(
            storage_module=module,
            storage_function=function,
            params=params,
            hasher=hasher,
            metadata_version=metadata_version
        )
        response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

        if &#39;result&#39; in response:

            if return_scale_type and response.get(&#39;result&#39;):
                obj = ScaleDecoder.get_decoder_class(
                    type_string=return_scale_type,
                    data=ScaleBytes(response.get(&#39;result&#39;)),
                    metadata=metadata,
                    runtime_config=self.runtime_config
                )
                return obj.decode()
            else:
                return response.get(&#39;result&#39;)
        else:
            raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)

    def get_storage_by_key(self, block_hash, storage_key):
        &#34;&#34;&#34;
        A pass-though to existing JSONRPC method `state_getStorageAt`

        Parameters
        ----------
        block_hash
        storage_key

        Returns
        -------

        &#34;&#34;&#34;

        response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_key, block_hash])
        if &#39;result&#39; in response:
            return response.get(&#39;result&#39;)
        else:
            raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)

    def get_block_events(self, block_hash, metadata_decoder=None):
        &#34;&#34;&#34;
        A convenience method to fetch the undecoded events from storage

        Parameters
        ----------
        block_hash
        metadata_decoder

        Returns
        -------

        &#34;&#34;&#34;

        if metadata_decoder and metadata_decoder.version.index &gt;= 9:
            storage_hash = STORAGE_HASH_SYSTEM_EVENTS_V9
        else:
            storage_hash = STORAGE_HASH_SYSTEM_EVENTS

        response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

        if response.get(&#39;result&#39;):

            if metadata_decoder:
                # Process events
                events_decoder = EventsDecoder(
                    data=ScaleBytes(response.get(&#39;result&#39;)),
                    metadata=metadata_decoder,
                    runtime_config=self.runtime_config
                )
                events_decoder.decode()

                return events_decoder

            else:
                return response
        else:
            raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)

    def get_block_runtime_version(self, block_hash):
        &#34;&#34;&#34;
        Retrieve the runtime version id of given block_hash
        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        response = self.rpc_request(&#34;chain_getRuntimeVersion&#34;, [block_hash])
        return response.get(&#39;result&#39;)

    def generate_storage_hash(self, storage_module, storage_function, params=None, hasher=None, key2_hasher=None, metadata_version=None):
        &#34;&#34;&#34;
        Generate a storage key for given module/function

        Parameters
        ----------
        storage_module
        storage_function
        params: Parameters of the storage function, provided in scale encoded hex-bytes
        hasher: Hashing method used to determine storage key, defaults to &#39;Twox64Concat&#39; if not provided
        metadata_version: Version index of Metadata, e.g. 9 for MetadataV9

        Returns
        -------

        &#34;&#34;&#34;

        if not metadata_version or metadata_version &gt;= 9:
            storage_hash = xxh128(storage_module.encode()) + xxh128(storage_function.encode())

            if params:

                if type(params) is not list:
                    params = [params]

                for idx, param in enumerate(params):
                    if idx == 0:
                        param_hasher = hasher
                    elif idx == 1:
                        param_hasher = key2_hasher
                    else:
                        raise ValueError(&#39;Unexpected third parameter for storage call&#39;)

                    params_key = bytes()

                    if type(param) is str:
                        params_key += binascii.unhexlify(param)
                    elif type(param) is ScaleBytes:
                        params_key += param.data
                    elif isinstance(param, ScaleDecoder):
                        params_key += param.data.data

                    if not param_hasher:
                        param_hasher = &#39;Twox128&#39;

                    if param_hasher == &#39;Blake2_256&#39;:
                        storage_hash += blake2_256(params_key)

                    elif param_hasher == &#39;Blake2_128&#39;:
                        storage_hash += blake2_128(params_key)

                    elif param_hasher == &#39;Blake2_128Concat&#39;:
                        storage_hash += blake2_128_concat(params_key)

                    elif param_hasher == &#39;Twox128&#39;:
                        storage_hash += xxh128(params_key)

                    elif param_hasher == &#39;Twox64Concat&#39;:
                        storage_hash += two_x64_concat(params_key)

                    elif param_hasher == &#39;Identity&#39;:
                        storage_hash += identity(params_key)

                    else:
                        raise ValueError(&#39;Unknown storage hasher &#34;{}&#34;&#39;.format(param_hasher))

            return &#39;0x{}&#39;.format(storage_hash)

        else:
            storage_hash = storage_module.encode() + b&#34; &#34; + storage_function.encode()

            if params:
                storage_hash += binascii.unhexlify(params)

            # Determine hasher function
            if not hasher:
                hasher = &#39;Twox128&#39;

            if hasher == &#39;Blake2_256&#39;:
                return &#34;0x{}&#34;.format(blake2_256(storage_hash))

            elif hasher == &#39;Twox128&#39;:
                return &#34;0x{}&#34;.format(xxh128(storage_hash))

            elif hasher == &#39;Twox64Concat&#39;:
                return &#34;0x{}&#34;.format(two_x64_concat(storage_hash))

    def convert_storage_parameter(self, scale_type, value):
        if scale_type == &#39;AccountId&#39;:
            if value[0:2] != &#39;0x&#39;:
                return &#39;0x{}&#39;.format(ss58_decode(value, self.ss58_format))

        return value

    # Runtime functions used by Substrate API

    def init_runtime(self, block_hash=None, block_id=None):
        &#34;&#34;&#34;
        This method is used by all other methods that deals with metadata and types defined in the type registry.
        It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that
        block_hash. Also it applies all the versioned types at the time of the block_hash.

        Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.
        In the future there could be support for caching backends like Redis to make this cache more persistent.

        Parameters
        ----------
        block_hash
        block_id

        Returns
        -------

        &#34;&#34;&#34;

        if block_id and block_hash:
            raise ValueError(&#39;Cannot provide block_hash and block_id at the same time&#39;)

        # Check if runtime state already set to current block
        if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):
            return

        if block_id is not None:
            block_hash = self.get_block_hash(block_id)

        self.block_hash = block_hash
        self.block_id = block_id

        # In fact calls and storage functions are decoded against runtime of previous block, therefor retrieve
        # metadata and apply type registry of runtime of parent block
        block_header = self.get_block_header(block_hash=self.block_hash) or {}
        parent_block_hash = block_header.get(&#39;parentHash&#39;)

        if parent_block_hash == &#39;0x0000000000000000000000000000000000000000000000000000000000000000&#39;:
            runtime_block_hash = self.block_hash
        else:
            runtime_block_hash = parent_block_hash

        runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)

        if runtime_info is None:
            raise SubstrateRequestException(f&#34;No runtime information for block &#39;{block_hash}&#39;&#34;)

        # Check if runtime state already set to current block
        if runtime_info.get(&#34;specVersion&#34;) == self.runtime_version:
            return

        self.runtime_version = runtime_info.get(&#34;specVersion&#34;)
        self.transaction_version = runtime_info.get(&#34;transactionVersion&#34;)

        # Set active runtime version
        self.runtime_config.set_active_spec_version_id(self.runtime_version)

        if self.runtime_version not in self.metadata_cache and self.cache_region:
            # Try to retrieve metadata from Dogpile cache
            cached_metadata = self.cache_region.get(&#39;METADATA_{}&#39;.format(self.runtime_version))
            if cached_metadata:
                self.debug_message(&#39;Retrieved metadata for {} from Redis&#39;.format(self.runtime_version))
                self.metadata_cache[self.runtime_version] = cached_metadata

        if self.runtime_version in self.metadata_cache:
            # Get metadata from cache
            self.debug_message(&#39;Retrieved metadata for {} from memory&#39;.format(self.runtime_version))
            self.metadata_decoder = self.metadata_cache[self.runtime_version]
        else:
            self.metadata_decoder = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)
            self.debug_message(&#39;Retrieved metadata for {} from Substrate node&#39;.format(self.runtime_version))

            # Update metadata cache
            self.metadata_cache[self.runtime_version] = self.metadata_decoder

            if self.cache_region:
                self.debug_message(&#39;Stored metadata for {} in Redis&#39;.format(self.runtime_version))
                self.cache_region.set(&#39;METADATA_{}&#39;.format(self.runtime_version), self.metadata_decoder)

    def iterate_map(self, module, storage_function, block_hash=None):
        &#34;&#34;&#34;
        iterates over all key-pairs localted at the given module and storage_function. The storage
        item must be a map.

        Parameters
        ----------
        module: The module name in the metadata, e.g. Balances or Account.
        storage_function: The storage function name, e.g. FreeBalance or AccountNonce.
        block_hash: Optional block hash, when left to None the chain tip will be used.

        Returns
        -------
        A two dimensional list of key-value pairs, both decoded into the given type, e.g.
        [[k1, v1], [k2, v2], ...]
        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        key_type = None
        value_type = None
        concat_hash_len = None
        for metadata_module in self.metadata_decoder.metadata.modules:
            if metadata_module.name == module:
                if metadata_module.storage:
                    for storage_item in metadata_module.storage.items:
                        if storage_item.name == storage_function:
                            if &#39;MapType&#39; in storage_item.type:
                                key_type = storage_item.type[&#39;MapType&#39;][&#39;key&#39;]
                                value_type = storage_item.type[&#39;MapType&#39;][&#39;value&#39;]
                                if storage_item.type[&#39;MapType&#39;][&#39;hasher&#39;] == &#34;Blake2_128Concat&#34;:
                                    concat_hash_len = 32
                                elif storage_item.type[&#39;MapType&#39;][&#39;hasher&#39;] == &#34;Twox64Concat&#34;:
                                    concat_hash_len = 16
                                else:
                                    raise ValueError(&#39;Unsupported hash type&#39;)
                            else:
                                raise ValueError(&#39;Given storage is not a map&#39;)

        prefix = self.generate_storage_hash(module, storage_function)
        prefix_len = len(prefix)
        pairs = self.rpc_request(method=&#34;state_getPairs&#34;, params=[prefix, block_hash]).get(&#39;result&#39;)

        # convert keys to the portion that needs to be decoded.
        pairs = map(lambda kp: [&#34;0x&#34; + kp[0][prefix_len + concat_hash_len:], kp[1]], pairs)

        # decode both of them
        pairs = map(
            lambda kp: [self.decode_scale(key_type, kp[0]), self.decode_scale(value_type, kp[1])],
            list(pairs)
        )

        return list(pairs)

    def query(self, module, storage_function, params=None, block_hash=None) -&gt; typing.Optional[ScaleType]:
        &#34;&#34;&#34;
        Retrieves the storage entry for given module, function and optional parameters at given block hash

        Parameters
        ----------
        module: The module name in the metadata, e.g. Balances or Account
        storage_function: The storage function name, e.g. FreeBalance or AccountNonce
        params: list of params, in the decoded format of the applicable ScaleTypes
        block_hash: Optional block hash, when omitted the chain tip will be used

        Returns
        -------
        ScaleType
        &#34;&#34;&#34;

        self.init_runtime(block_hash=block_hash)

        # Search storage call in metadata
        for metadata_module in self.metadata_decoder.metadata.modules:
            if metadata_module.name == module:
                if metadata_module.storage:
                    for storage_item in metadata_module.storage.items:
                        if storage_item.name == storage_function:

                            key2_hasher = None

                            if &#39;PlainType&#39; in storage_item.type:
                                hasher = &#39;Twox64Concat&#39;
                                return_scale_type = storage_item.type.get(&#39;PlainType&#39;)
                                if params:
                                    raise ValueError(&#39;Storage call of type &#34;PlainType&#34; doesn\&#39;t accept params&#39;)

                            elif &#39;MapType&#39; in storage_item.type:

                                map_type = storage_item.type.get(&#39;MapType&#39;)
                                hasher = map_type.get(&#39;hasher&#39;)
                                return_scale_type = map_type.get(&#39;value&#39;)

                                if not params or len(params) != 1:
                                    raise ValueError(&#39;Storage call of type &#34;MapType&#34; requires 1 parameter&#39;)

                                # Encode parameter
                                params[0] = self.convert_storage_parameter(map_type[&#39;key&#39;], params[0])
                                param_obj = ScaleDecoder.get_decoder_class(
                                    type_string=map_type[&#39;key&#39;], runtime_config=self.runtime_config
                                )
                                params[0] = param_obj.encode(params[0])

                            elif &#39;DoubleMapType&#39; in storage_item.type:

                                map_type = storage_item.type.get(&#39;DoubleMapType&#39;)
                                hasher = map_type.get(&#39;hasher&#39;)
                                key2_hasher = map_type.get(&#39;key2Hasher&#39;)
                                return_scale_type = map_type.get(&#39;value&#39;)

                                if not params or len(params) != 2:
                                    raise ValueError(&#39;Storage call of type &#34;DoubleMapType&#34; requires 2 parameters&#39;)

                                # Encode parameter 1
                                params[0] = self.convert_storage_parameter(map_type[&#39;key1&#39;], params[0])
                                param_obj = ScaleDecoder.get_decoder_class(
                                    type_string=map_type[&#39;key1&#39;], runtime_config=self.runtime_config
                                )
                                params[0] = param_obj.encode(params[0])

                                # Encode parameter 2
                                params[1] = self.convert_storage_parameter(map_type[&#39;key2&#39;], params[1])
                                param_obj = ScaleDecoder.get_decoder_class(
                                    type_string=map_type[&#39;key2&#39;], runtime_config=self.runtime_config
                                )
                                params[1] = param_obj.encode(params[1])

                            else:
                                raise NotImplementedError(&#34;Storage type not implemented&#34;)

                            storage_hash = self.generate_storage_hash(
                                storage_module=metadata_module.prefix,
                                storage_function=storage_function,
                                params=params,
                                hasher=hasher,
                                key2_hasher=key2_hasher,
                                metadata_version=self.metadata_decoder.version.index
                            )

                            response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

                            if &#39;result&#39; in response:

                                if return_scale_type and response.get(&#39;result&#39;):
                                    obj = ScaleDecoder.get_decoder_class(
                                        type_string=return_scale_type,
                                        data=ScaleBytes(response.get(&#39;result&#39;)),
                                        metadata=self.metadata_decoder,
                                        runtime_config=self.runtime_config
                                    )
                                    obj.decode()
                                    return obj

                            return None

        raise StorageFunctionNotFound(&#39;Storage function &#34;{}.{}&#34; not found&#39;.format(module, storage_function))

    def get_runtime_state(self, module, storage_function, params=None, block_hash=None):
        warnings.warn(&#34;&#39;get_runtime_state&#39; will be replaced by &#39;query&#39;&#34;, DeprecationWarning)

        obj = self.query(module, storage_function, params=params, block_hash=block_hash)
        return {&#39;result&#39;: obj.value if obj else None}

    def get_events(self, block_hash=None) -&gt; list:
        &#34;&#34;&#34;
        Convenience method to get events for a certain block (storage call for module &#39;System&#39; and function &#39;Events&#39;)

        Parameters
        ----------
        block_hash

        Returns
        -------
        list
        &#34;&#34;&#34;
        events = []
        storage_obj = self.query(module=&#34;System&#34;, storage_function=&#34;Events&#34;, block_hash=block_hash)
        if storage_obj:
            events += storage_obj.elements
        return events

    def get_runtime_events(self, block_hash=None):

        warnings.warn(&#34;&#39;get_runtime_events&#39; will be replaced by &#39;get_events&#39;&#34;, DeprecationWarning)

        &#34;&#34;&#34;
        Convenience method to get events for a certain block (storage call for module &#39;System&#39; and function &#39;Events&#39;)

        Parameters
        ----------
        block_hash

        Returns
        -------
        Collection of events
        &#34;&#34;&#34;
        return self.get_runtime_state(
            module=&#34;System&#34;,
            storage_function=&#34;Events&#34;,
            block_hash=block_hash
        )

    def get_runtime_metadata(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves and decodes the metadata for given block or chaintip if block_hash is omitted.

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        params = None
        if block_hash:
            params = [block_hash]
        response = self.rpc_request(&#34;state_getMetadata&#34;, params)

        if &#39;result&#39; in response:
            metadata_decoder = MetadataDecoder(ScaleBytes(response.get(&#39;result&#39;)))
            response[&#39;result&#39;] = metadata_decoder.decode()

        return response

    def compose_call(self, call_module, call_function, call_params=(), block_hash=None):
        &#34;&#34;&#34;
        Composes a call payload which can be used as an unsigned extrinsic or a proposal.

        Parameters
        ----------
        call_module: Name of the runtime module e.g. Balances
        call_function: Name of the call function e.g. transfer
        call_params: This is a dict containing the params of the call. e.g. `{&#39;dest&#39;: &#39;EaG2CRhJWPb7qmdcJvy3LiWdh26Jreu9Dx6R1rXxPmYXoDk&#39;, &#39;value&#39;: 1000000000000}`
        block_hash: Use metadata at given block_hash to compose call

        Returns
        -------
        GenericCall
        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        call = ScaleDecoder.get_decoder_class(
            type_string=&#39;Call&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
        )

        call.encode({
            &#39;call_module&#39;: call_module,
            &#39;call_function&#39;: call_function,
            &#39;call_args&#39;: call_params
        })

        return call

    def get_account_nonce(self, account_address):
        &#34;&#34;&#34;
        Returns current nonce for given account address

        Parameters
        ----------
        account_address: SS58 formatted address

        Returns
        -------
        int
        &#34;&#34;&#34;
        account_info = self.query(&#39;System&#39;, &#39;Account&#39;, [account_address])
        if account_info:
            return account_info.value.get(&#39;nonce&#39;, 0)

    def generate_signature_payload(self, call, era=None, nonce=0, tip=0, include_call_length=False):

        # Retrieve genesis hash
        genesis_hash = self.get_block_hash(0)

        if not era:
            era = &#39;00&#39;

        if era == &#39;00&#39;:
            block_hash = genesis_hash
        else:
            era_obj = ScaleDecoder.get_decoder_class(&#39;Era&#39;, runtime_config=self.runtime_config)

            if isinstance(era, dict) and &#39;current&#39; not in era and &#39;phase&#39; not in era:
                raise ValueError(&#39;The era dict must contain either &#34;current&#34; or &#34;phase&#34; element to encode a valid era&#39;)

            era_obj.encode(era)
            block_hash = self.get_block_hash(block_id=era_obj.birth(era.get(&#39;current&#39;)))

        # Create signature payload
        signature_payload = ScaleDecoder.get_decoder_class(&#39;ExtrinsicPayloadValue&#39;, runtime_config=self.runtime_config)

        if include_call_length:

            length_obj = self.runtime_config.get_decoder_class(&#39;Bytes&#39;)
            call_data = str(length_obj().encode(str(call.data)))

        else:
            call_data = str(call.data)

        payload_dict = {
            &#39;call&#39;: call_data,
            &#39;era&#39;: era,
            &#39;nonce&#39;: nonce,
            &#39;tip&#39;: tip,
            &#39;specVersion&#39;: self.runtime_version,
            &#39;genesisHash&#39;: genesis_hash,
            &#39;blockHash&#39;: block_hash
        }

        if self.transaction_version is not None:
            payload_dict[&#39;transactionVersion&#39;] = self.transaction_version

        signature_payload.encode(payload_dict)

        if signature_payload.data.length &gt; 256:
            return ScaleBytes(data=blake2b(signature_payload.data.data, digest_size=32).digest())

        return signature_payload.data

    def create_signed_extrinsic(self, call, keypair: Keypair, era=None, nonce=None, tip=0, signature=None):
        &#34;&#34;&#34;
        Creates a extrinsic signed by given account details

        Parameters
        ----------
        call: GenericCall to create extrinsic for
        keypair: Keypair used to sign the extrinsic
        era: Specify mortality in blocks in follow format: {&#39;period&#39;: &lt;amount_blocks&gt;} If omitted the extrinsic is immortal
        nonce: nonce to include in extrinsics, if omitted the current nonce is retrieved on-chain
        tip: specify tip to gain priority during network congestion
        signature: Optionally provide signature if externally signed

        Returns
        -------
        ExtrinsicsDecoder The signed Extrinsic
        &#34;&#34;&#34;

        # Check requirements
        if not isinstance(call, GenericCall):
            raise TypeError(&#34;&#39;call&#39; must be of type Call&#34;)

        # Retrieve nonce
        if nonce is None:
            nonce = self.get_account_nonce(keypair.public_key) or 0

        # Process era
        if era is None:
            era = &#39;00&#39;
        else:
            if isinstance(era, dict) and &#39;current&#39; not in era and &#39;phase&#39; not in era:
                # Retrieve current block id
                era[&#39;current&#39;] = self.get_block_number(self.get_chain_finalised_head())

        if signature is not None:

            signature = signature.replace(&#39;0x&#39;, &#39;&#39;)

            # Check if signature is a MultiSignature and contains signature version
            if len(signature) == 130:
                signature_version = int(signature[0:2], 16)
                signature = &#39;0x{}&#39;.format(signature[2:])
            else:
                signature_version = keypair.crypto_type

        else:
            # Create signature payload
            signature_payload = self.generate_signature_payload(call=call, era=era, nonce=nonce, tip=tip)

            # Set Signature version to crypto type of keypair
            signature_version = keypair.crypto_type

            # Sign payload
            signature = keypair.sign(signature_payload)

        # Create extrinsic
        extrinsic = ScaleDecoder.get_decoder_class(
            type_string=&#39;Extrinsic&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
        )

        extrinsic.encode({
            &#39;account_id&#39;: keypair.public_key,
            &#39;signature_version&#39;: signature_version,
            &#39;signature&#39;: signature,
            &#39;call_function&#39;: call.value[&#39;call_function&#39;],
            &#39;call_module&#39;: call.value[&#39;call_module&#39;],
            &#39;call_args&#39;: call.value[&#39;call_args&#39;],
            &#39;nonce&#39;: nonce,
            &#39;era&#39;: era,
            &#39;tip&#39;: tip
        })

        # Set extrinsic hash
        extrinsic.extrinsic_hash = extrinsic.generate_hash()

        return extrinsic

    def create_unsigned_extrinsic(self, call):
        &#34;&#34;&#34;
        Create unsigned extrinsic for given `Call`
        Parameters
        ----------
        call: GenericCall the call the extrinsic should contain

        Returns
        -------
        ExtrinsicsDecoder
        &#34;&#34;&#34;
        # Create extrinsic
        extrinsic = ScaleDecoder.get_decoder_class(
            type_string=&#39;Extrinsic&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
        )

        extrinsic.encode({
            &#39;call_function&#39;: call.value[&#39;call_function&#39;],
            &#39;call_module&#39;: call.value[&#39;call_module&#39;],
            &#39;call_args&#39;: call.value[&#39;call_args&#39;]
        })

        return extrinsic

    def submit_extrinsic(self, extrinsic, wait_for_inclusion=False, wait_for_finalization=False) -&gt; &#34;ExtrinsicReceipt&#34;:
        &#34;&#34;&#34;

        Parameters
        ----------
        extrinsic: ExtrinsicsDecoder The extinsic to be send to the network
        wait_for_inclusion: wait until extrinsic is included in a block (only works for websocket connections)
        wait_for_finalization: wait until extrinsic is finalized (only works for websocket connections)

        Returns
        -------
        The hash of the extrinsic submitted to the network

        &#34;&#34;&#34;

        # Check requirements
        if extrinsic.__class__.__name__ != &#39;ExtrinsicsDecoder&#39;:
            raise TypeError(&#34;&#39;extrinsic&#39; must be of type ExtrinsicsDecoder&#34;)

        def result_handler(result):
            # Check if extrinsic is included and finalized
            if &#39;params&#39; in result and type(result[&#39;params&#39;][&#39;result&#39;]) is dict:
                if &#39;finalized&#39; in result[&#39;params&#39;][&#39;result&#39;] and wait_for_finalization:
                    return {
                        &#39;block_hash&#39;: result[&#39;params&#39;][&#39;result&#39;][&#39;finalized&#39;],
                        &#39;extrinsic_hash&#39;: &#39;0x{}&#39;.format(extrinsic.extrinsic_hash),
                        &#39;finalized&#39;: True
                    }
                elif &#39;inBlock&#39; in result[&#39;params&#39;][&#39;result&#39;] and wait_for_inclusion and not wait_for_finalization:
                    return {
                        &#39;block_hash&#39;: result[&#39;params&#39;][&#39;result&#39;][&#39;inBlock&#39;],
                        &#39;extrinsic_hash&#39;: &#39;0x{}&#39;.format(extrinsic.extrinsic_hash),
                        &#39;finalized&#39;: False
                    }

        if wait_for_inclusion or wait_for_finalization:
            response = self.rpc_request(
                &#34;author_submitAndWatchExtrinsic&#34;,
                [str(extrinsic.data)],
                result_handler=result_handler
            )

            result = ExtrinsicReceipt(
                substrate=self,
                extrinsic_hash=response[&#39;extrinsic_hash&#39;],
                block_hash=response[&#39;block_hash&#39;],
                finalized=response[&#39;finalized&#39;]
            )

        else:

            response = self.rpc_request(&#34;author_submitExtrinsic&#34;, [str(extrinsic.data)])

            if &#39;result&#39; not in response:
                raise SubstrateRequestException(response.get(&#39;error&#39;))

            result = ExtrinsicReceipt(
                substrate=self,
                extrinsic_hash=response[&#39;result&#39;]
            )

        return result

    def get_payment_info(self, call, keypair):
        &#34;&#34;&#34;
        Retrieves fee estimation via RPC for given extrinsic

        Parameters
        ----------
        call Call object to estimate fees for
        keypair Keypair of the sender, does not have to include private key because no valid signature is required

        Returns
        -------
        Dict with payment info

        E.g. `{&#39;class&#39;: &#39;normal&#39;, &#39;partialFee&#39;: 151000000, &#39;weight&#39;: 217238000}`

        &#34;&#34;&#34;

        # Check requirements
        if not isinstance(call, GenericCall):
            raise TypeError(&#34;&#39;call&#39; must be of type Call&#34;)

        if not isinstance(keypair, Keypair):
            raise TypeError(&#34;&#39;keypair&#39; must be of type Keypair&#34;)

        # No valid signature is required for fee estimation
        signature = &#39;0x&#39; + &#39;00&#39; * 64

        # Create extrinsic
        extrinsic = self.create_signed_extrinsic(
            call=call,
            keypair=keypair,
            signature=signature
        )

        payment_info = self.rpc_request(&#39;payment_queryInfo&#39;, [str(extrinsic.data)])

        # convert partialFee to int
        if &#39;result&#39; in payment_info:
            payment_info[&#39;result&#39;][&#39;partialFee&#39;] = int(payment_info[&#39;result&#39;][&#39;partialFee&#39;])
            return payment_info[&#39;result&#39;]
        else:
            raise SubstrateRequestException(payment_info[&#39;error&#39;][&#39;message&#39;])

    def process_metadata_typestring(self, type_string):
        &#34;&#34;&#34;
        Process how given type_string is decoded with active runtime and type registry

        Parameters
        ----------
        type_string: RUST variable type, e.g. `Vec&lt;Address&gt;`

        Returns
        -------

        dict of properties for given type_string

        E.g.

        `{
            &#34;type_string&#34;: &#34;Vec&lt;Address&gt;&#34;,
            &#34;decoder_class&#34;: &#34;Vec&#34;,
            &#34;is_primitive_runtime&#34;: false,
            &#34;is_primitive_core&#34;: false,
            &#34;spec_version&#34;: 1030
        }`

        &#34;&#34;&#34;
        decoder_class_obj = None

        type_info = {
            &#34;type_string&#34;: type_string,
            &#34;decoder_class&#34;: None,
            &#34;is_primitive_runtime&#34;: None,
            &#34;is_primitive_core&#34;: False,
            &#34;spec_version&#34;: self.runtime_version
        }

        if self.runtime_version not in self.type_registry_cache:
            self.type_registry_cache[self.runtime_version] = {}

        # Check if already added
        if type_string.lower() in self.type_registry_cache[self.runtime_version]:
            return self.type_registry_cache[self.runtime_version][type_string.lower()][&#39;decoder_class&#39;]

        # Try to get decoder class
        decoder_class = self.runtime_config.get_decoder_class(type_string)

        if not decoder_class:

            # Not in type registry, try get hard coded decoder classes
            try:
                decoder_class_obj = ScaleDecoder.get_decoder_class(
                    type_string=type_string, runtime_config=self.runtime_config
                )
                decoder_class = decoder_class_obj.__class__
            except NotImplementedError as e:
                decoder_class = None

        # Process classes that contain subtypes (e.g. Option&lt;ChangesTrieConfiguration&gt;)
        if decoder_class_obj and decoder_class_obj.sub_type:
            type_info[&#34;is_primitive_runtime&#34;] = False

            # Try to split on &#39;,&#39; (e.g. ActiveRecovery&lt;BlockNumber, BalanceOf, AccountId&gt;)
            if not re.search(&#39;[&lt;()&gt;]&#39;, decoder_class_obj.sub_type):
                for element in decoder_class_obj.sub_type.split(&#39;,&#39;):
                    if element not in [&#39;T&#39;, &#39;I&#39;]:
                        self.process_metadata_typestring(element.strip())

        # Process classes that contain type_mapping (e.g. Struct and Enum)
        if decoder_class and hasattr(decoder_class, &#39;type_mapping&#39;) and decoder_class.type_mapping:

            if type_string[0] == &#39;(&#39;:
                type_info[&#34;is_primitive_runtime&#34;] = False

            for key, data_type in decoder_class.type_mapping:
                self.process_metadata_typestring(data_type)

        # Try to get superclass as actual decoding class if not root level &#39;ScaleType&#39;
        if decoder_class and len(decoder_class.__mro__) &gt; 1 and decoder_class.__mro__[1].__name__ != &#39;ScaleType&#39;:
            decoder_class = decoder_class.__mro__[1]

        if decoder_class:
            type_info[&#39;decoder_class&#39;] = decoder_class.__name__

            if type_info[&#34;is_primitive_runtime&#34;] is None:
                type_info[&#34;is_primitive_runtime&#34;] = True

            if type_info[&#34;is_primitive_runtime&#34;] and type_string.lower() in ScaleDecoder.PRIMITIVES:
                type_info[&#34;is_primitive_core&#34;] = True
        else:
            type_info[&#34;is_primitive_runtime&#34;] = None
            type_info[&#34;is_primitive_core&#34;] = None

        self.type_registry_cache[self.runtime_version][type_string.lower()] = type_info

        return decoder_class

    def get_type_registry(self, block_hash=None):
        &#34;&#34;&#34;
        Generates an exhaustive list of which RUST types exist in the runtime specified at given block_hash (or
        chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash: Chaintip will be used if block_hash is omitted

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        if self.runtime_version not in self.type_registry_cache:

            for module in self.metadata_decoder.metadata.modules:

                # Storage backwards compt check
                if module.storage and isinstance(module.storage, list):
                    storage_functions = module.storage
                elif module.storage and isinstance(getattr(module.storage, &#39;value&#39;), dict):
                    storage_functions = module.storage.items
                else:
                    storage_functions = []

                if len(module.calls or []) &gt; 0:
                    for idx, call in enumerate(module.calls):
                        for arg in call.args:
                            self.process_metadata_typestring(arg.type)

                if len(module.events or []) &gt; 0:
                    for event_index, event in enumerate(module.events):

                        for arg_index, arg in enumerate(event.args):
                            self.process_metadata_typestring(arg)

                if len(storage_functions) &gt; 0:
                    for idx, storage in enumerate(storage_functions):

                        # Determine type
                        type_key1 = None
                        type_key2 = None
                        type_value = None

                        if storage.type.get(&#39;PlainType&#39;):
                            type_value = storage.type.get(&#39;PlainType&#39;)

                        elif storage.type.get(&#39;MapType&#39;):
                            type_key1 = storage.type[&#39;MapType&#39;].get(&#39;key&#39;)
                            type_value = storage.type[&#39;MapType&#39;].get(&#39;value&#39;)

                        elif storage.type.get(&#39;DoubleMapType&#39;):
                            type_key1 = storage.type[&#39;DoubleMapType&#39;].get(&#39;key1&#39;)
                            type_key2 = storage.type[&#39;DoubleMapType&#39;].get(&#39;key2&#39;)
                            type_value = storage.type[&#39;DoubleMapType&#39;].get(&#39;value&#39;)

                        self.process_metadata_typestring(type_value)

                        if type_key1:
                            self.process_metadata_typestring(type_key1)

                        if type_key2:
                            self.process_metadata_typestring(type_key2)

                if len(module.constants or []) &gt; 0:
                    for idx, constant in enumerate(module.constants):

                        # Check if types already registered in database
                        self.process_metadata_typestring(constant.type)

        return self.type_registry_cache[self.runtime_version]

    def get_type_definition(self, type_string, block_hash=None):
        &#34;&#34;&#34;
        Retrieves decoding specifications of given type_string

        Parameters
        ----------
        type_string: RUST variable type, e.g. Vec&lt;Address&gt;
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        type_registry = self.get_type_registry(block_hash=block_hash)
        return type_registry.get(type_string.lower())

    def get_metadata_modules(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of modules in metadata for given block_hash (or chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        return [{
            &#39;metadata_index&#39;: idx,
            &#39;module_id&#39;: module.get_identifier(),
            &#39;name&#39;: module.name,
            &#39;prefix&#39;: module.prefix,
            &#39;spec_version&#39;: self.runtime_version,
            &#39;count_call_functions&#39;: len(module.calls or []),
            &#39;count_storage_functions&#39;: len(module.calls or []),
            &#39;count_events&#39;: len(module.events or []),
            &#39;count_constants&#39;: len(module.constants or []),
            &#39;count_errors&#39;: len(module.errors or []),
        } for idx, module in enumerate(self.metadata_decoder.metadata.modules)]

    def get_metadata_call_functions(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of all call functions in metadata active for given block_hash (or chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        call_list = []

        for call_index, (module, call) in self.metadata_decoder.call_index.items():
            call_list.append(
                self.serialize_module_call(
                    module, call, self.runtime_version, call_index
                )
            )
        return call_list

    def get_metadata_call_function(self, module_name, call_function_name, block_hash=None):
        &#34;&#34;&#34;
        Retrieves the details of a call function given module name, call function name and block_hash
        (or chaintip if block_hash is omitted)

        Parameters
        ----------
        module_name
        call_function_name
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        result = None

        for call_index, (module, call) in self.metadata_decoder.call_index.items():
            if module.name == module_name and \
                    call.get_identifier() == call_function_name:
                result = self.serialize_module_call(
                    module, call, self.runtime_version, call_index
                )
                break

        return result

    def get_metadata_events(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of all events in metadata active for given block_hash (or chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;

        self.init_runtime(block_hash=block_hash)

        event_list = []

        for event_index, (module, event) in self.metadata_decoder.event_index.items():
            event_list.append(
                self.serialize_module_event(
                    module, event, self.runtime_version, event_index
                )
            )

        return event_list

    def get_metadata_event(self, module_name, event_name, block_hash=None):
        &#34;&#34;&#34;
        Retrieves the details of an event for given module name, call function name and block_hash
        (or chaintip if block_hash is omitted)

        Parameters
        ----------
        module_name
        event_name
        block_hash

        Returns
        -------

        &#34;&#34;&#34;

        self.init_runtime(block_hash=block_hash)

        for event_index, (module, event) in self.metadata_decoder.event_index.items():
            if module.name == module_name and \
                    event.name == event_name:
                return self.serialize_module_event(
                    module, event, self.runtime_version, event_index
                )

    def get_metadata_constants(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of all constants in metadata active at given block_hash (or chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;

        self.init_runtime(block_hash=block_hash)

        constant_list = []

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
            for constant in module.constants or []:
                constant_list.append(
                    self.serialize_constant(
                        constant, module, self.runtime_version
                    )
                )

        return constant_list

    def get_metadata_constant(self, module_name, constant_name, block_hash=None):
        &#34;&#34;&#34;
        Retrieves the details of a constant for given module name, call function name and block_hash
        (or chaintip if block_hash is omitted)

        Parameters
        ----------
        module_name
        constant_name
        block_hash

        Returns
        -------

        &#34;&#34;&#34;

        self.init_runtime(block_hash=block_hash)

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):

            if module_name == module.name and module.constants:

                for constant in module.constants:
                    if constant_name == constant.name:
                        return self.serialize_constant(
                            constant, module, self.runtime_version
                        )

    def get_metadata_storage_functions(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of all storage functions in metadata active at given block_hash (or chaintip if block_hash is
        omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        storage_list = []

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
            if module.storage:
                for storage in module.storage.items:
                    storage_list.append(
                        self.serialize_storage_item(
                            storage_item=storage,
                            module=module,
                            spec_version_id=self.runtime_version
                        )
                    )

        return storage_list

    def get_metadata_storage_function(self, module_name, storage_name, block_hash=None):
        &#34;&#34;&#34;
        Retrieves the details of a storage function for given module name, call function name and block_hash

        Parameters
        ----------
        module_name
        storage_name
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
            if module.name == module_name and module.storage:
                for storage in module.storage.items:
                    if storage.name == storage_name:
                        return self.serialize_storage_item(
                            storage_item=storage,
                            module=module,
                            spec_version_id=self.runtime_version
                        )

    def get_metadata_errors(self, block_hash=None):
        &#34;&#34;&#34;
        Retrieves a list of all errors in metadata active at given block_hash (or chaintip if block_hash is omitted)

        Parameters
        ----------
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        error_list = []

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
            if module.errors:
                for error in module.errors:
                    error_list.append(
                        self.serialize_module_error(
                            module=module, error=error, spec_version=self.runtime_version
                        )
                    )

        return error_list

    def get_metadata_error(self, module_name, error_name, block_hash=None):
        &#34;&#34;&#34;
        Retrieves the details of an error for given module name, call function name and block_hash

        Parameters
        ----------
        module_name
        error_name
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
            if module.name == module_name and module.errors:
                for error in module.errors:
                    if error_name == error.name:
                        return self.serialize_module_error(
                            module=module, error=error, spec_version=self.runtime_version
                        )

    def get_runtime_block(self, block_hash=None, block_id=None):
        &#34;&#34;&#34;
        Retrieves a block with method `chain_getBlock` and in addition decodes extrinsics and log items

        Parameters
        ----------
        block_hash
        block_id

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash, block_id=block_id)

        response = self.rpc_request(&#34;chain_getBlock&#34;, [self.block_hash]).get(&#39;result&#39;)

        if response:
            response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;] = int(response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;], 16)

            for idx, extrinsic_data in enumerate(response[&#39;block&#39;][&#39;extrinsics&#39;]):
                extrinsic_decoder = Extrinsic(
                    data=ScaleBytes(extrinsic_data),
                    metadata=self.metadata_decoder,
                    runtime_config=self.runtime_config
                )
                extrinsic_decoder.decode()
                response[&#39;block&#39;][&#39;extrinsics&#39;][idx] = extrinsic_decoder.value

            for idx, log_data in enumerate(response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;]):
                log_digest = LogDigest(ScaleBytes(log_data), runtime_config=self.runtime_config)
                log_digest.decode()
                response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;][idx] = log_digest.value

        return response

    def get_block_extrinsics(self, block_hash: str = None, block_id: int = None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves a list of `Extrinsic` objects for given block_hash or block_id

        Parameters
        ----------
        block_hash
        block_id

        Returns
        -------
        list
        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash, block_id=block_id)

        response = self.rpc_request(&#34;chain_getBlock&#34;, [self.block_hash]).get(&#39;result&#39;)

        if response is None:
            raise BlockHashNotFound(f&#34;{block_hash} not found&#34;)

        extrinsics = []

        for extrinsic_data in response[&#39;block&#39;][&#39;extrinsics&#39;]:
            extrinsic = Extrinsic(
                data=ScaleBytes(extrinsic_data),
                metadata=self.metadata_decoder,
                runtime_config=self.runtime_config
            )
            extrinsic.decode()
            extrinsics.append(extrinsic)

        return extrinsics

    def decode_scale(self, type_string, scale_bytes, block_hash=None):
        &#34;&#34;&#34;
        Helper function to decode arbitrary SCALE-bytes (e.g. 0x02000000) according to given RUST type_string
        (e.g. BlockNumber). The relevant versioning information of the type (if defined) will be applied if block_hash
        is set

        Parameters
        ----------
        type_string
        scale_bytes
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        if type(scale_bytes) == str:
            scale_bytes = ScaleBytes(scale_bytes)

        obj = ScaleDecoder.get_decoder_class(
            type_string=type_string,
            data=scale_bytes,
            metadata=self.metadata_decoder,
            runtime_config=self.runtime_config
        )
        return obj.decode()

    def encode_scale(self, type_string, value, block_hash=None):
        &#34;&#34;&#34;
        Helper function to encode arbitrary data into SCALE-bytes for given RUST type_string

        Parameters
        ----------
        type_string
        value
        block_hash

        Returns
        -------

        &#34;&#34;&#34;
        self.init_runtime(block_hash=block_hash)

        obj = ScaleDecoder.get_decoder_class(
            type_string=type_string, metadata=self.metadata_decoder, runtime_config=self.runtime_config
        )
        return obj.encode(value)

    def ss58_encode(self, public_key: str) -&gt; str:
        &#34;&#34;&#34;
        Helper function to encode a public key to SS58 address

        Parameters
        ----------
        public_key

        Returns
        -------
        SS58 address
        &#34;&#34;&#34;
        return ss58_encode(public_key, ss58_format=self.ss58_format)

    def ss58_decode(self, ss58_address: str) -&gt; str:
        &#34;&#34;&#34;
        Helper function to decode a SS58 address to a public key

        Parameters
        ----------
        ss58_address

        Returns
        -------
        Public key
        &#34;&#34;&#34;
        return ss58_decode(ss58_address, valid_ss58_format=self.ss58_format)

    # Serializing helper function

    def serialize_storage_item(self, storage_item, module, spec_version_id):
        &#34;&#34;&#34;
        Helper function to serialize a storage item

        Parameters
        ----------
        storage_item
        module
        spec_version_id

        Returns
        -------

        &#34;&#34;&#34;
        storage_dict = {
            &#34;storage_name&#34;: storage_item.name,
            &#34;storage_modifier&#34;: storage_item.modifier,
            &#34;storage_fallback_scale&#34;: storage_item.fallback,
            &#34;storage_fallback&#34;: None,
            &#34;documentation&#34;: &#39;\n&#39;.join(storage_item.docs),
            &#34;module_id&#34;: module.get_identifier(),
            &#34;module_prefix&#34;: module.prefix,
            &#34;module_name&#34;: module.name,
            &#34;spec_version&#34;: spec_version_id,
            &#34;type_key1&#34;: None,
            &#34;type_key2&#34;: None,
            &#34;type_hasher_key1&#34;: None,
            &#34;type_hasher_key2&#34;: None,
            &#34;type_value&#34;: None,
            &#34;type_is_linked&#34;: None
        }

        type_class, type_info = next(iter(storage_item.type.items()))

        storage_dict[&#34;type_class&#34;] = type_class

        if type_class == &#39;PlainType&#39;:
            storage_dict[&#34;type_value&#34;] = type_info

        elif type_class == &#39;MapType&#39;:
            storage_dict[&#34;type_value&#34;] = type_info[&#34;value&#34;]
            storage_dict[&#34;type_key1&#34;] = type_info[&#34;key&#34;]
            storage_dict[&#34;type_hasher_key1&#34;] = type_info[&#34;hasher&#34;]
            storage_dict[&#34;type_is_linked&#34;] = type_info[&#34;isLinked&#34;]

        elif type_class == &#39;DoubleMapType&#39;:

            storage_dict[&#34;type_value&#34;] = type_info[&#34;value&#34;]
            storage_dict[&#34;type_key1&#34;] = type_info[&#34;key1&#34;]
            storage_dict[&#34;type_key2&#34;] = type_info[&#34;key2&#34;]
            storage_dict[&#34;type_hasher_key1&#34;] = type_info[&#34;hasher&#34;]
            storage_dict[&#34;type_hasher_key2&#34;] = type_info[&#34;key2Hasher&#34;]

        if storage_item.fallback != &#39;0x00&#39;:
            # Decode fallback
            try:
                fallback_obj = ScaleDecoder.get_decoder_class(
                    type_string=storage_dict[&#34;type_value&#34;],
                    data=ScaleBytes(storage_item.fallback),
                    runtime_config=self.runtime_config
                )
                storage_dict[&#34;storage_fallback&#34;] = fallback_obj.decode()
            except Exception:
                storage_dict[&#34;storage_fallback&#34;] = &#39;[decoding error]&#39;

        return storage_dict

    def serialize_constant(self, constant, module, spec_version_id):
        &#34;&#34;&#34;
        Helper function to serialize a constant

        Parameters
        ----------
        constant
        module
        spec_version_id

        Returns
        -------

        &#34;&#34;&#34;
        try:
            value_obj = ScaleDecoder.get_decoder_class(
                type_string=constant.type, data=ScaleBytes(constant.constant_value), runtime_config=self.runtime_config
            )
            constant_decoded_value = value_obj.decode()
        except Exception:
            constant_decoded_value = &#39;[decoding error]&#39;

        return {
            &#34;constant_name&#34;: constant.name,
            &#34;constant_type&#34;: constant.type,
            &#34;constant_value&#34;: constant_decoded_value,
            &#34;constant_value_scale&#34;: constant.constant_value,
            &#34;documentation&#34;: &#39;\n&#39;.join(constant.docs),
            &#34;module_id&#34;: module.get_identifier(),
            &#34;module_prefix&#34;: module.prefix,
            &#34;module_name&#34;: module.name,
            &#34;spec_version&#34;: spec_version_id
        }

    def serialize_module_call(self, module, call, spec_version, call_index):
        &#34;&#34;&#34;
        Helper function to serialize a call function

        Parameters
        ----------
        module
        call
        spec_version
        call_index

        Returns
        -------

        &#34;&#34;&#34;
        return {
            &#34;call_id&#34;: call.get_identifier(),
            &#34;call_name&#34;: call.name,
            &#34;call_args&#34;: [call_arg.value for call_arg in call.args],
            &#34;lookup&#34;: &#39;0x{}&#39;.format(call_index),
            &#34;documentation&#34;: &#39;\n&#39;.join(call.docs),
            &#34;module_id&#34;: module.get_identifier(),
            &#34;module_prefix&#34;: module.prefix,
            &#34;module_name&#34;: module.name,
            &#34;spec_version&#34;: spec_version
        }

    def serialize_module_event(self, module, event, spec_version, event_index):
        &#34;&#34;&#34;
        Helper function to serialize an event

        Parameters
        ----------
        module
        event
        spec_version
        event_index

        Returns
        -------

        &#34;&#34;&#34;
        return {
            &#34;event_id&#34;: event.name,
            &#34;event_name&#34;: event.name,
            &#34;event_args&#34;: [
                  {
                    &#34;event_arg_index&#34;: idx,
                    &#34;type&#34;: arg
                  } for idx, arg in enumerate(event.args)
                ],
            &#34;lookup&#34;: &#39;0x{}&#39;.format(event_index),
            &#34;documentation&#34;: &#39;\n&#39;.join(event.docs),
            &#34;module_id&#34;: module.get_identifier(),
            &#34;module_prefix&#34;: module.prefix,
            &#34;module_name&#34;: module.name,
            &#34;spec_version&#34;: spec_version
        }

    def serialize_module_error(self, module, error, spec_version):
        &#34;&#34;&#34;
        Helper function to serialize an error

        Parameters
        ----------
        module
        error
        spec_version

        Returns
        -------

        &#34;&#34;&#34;
        return {
            &#34;error_name&#34;: error.name,
            &#34;documentation&#34;: &#39;\n&#39;.join(error.docs),
            &#34;module_id&#34;: module.get_identifier(),
            &#34;module_prefix&#34;: module.prefix,
            &#34;module_name&#34;: module.name,
            &#34;spec_version&#34;: spec_version
        }

    def update_type_registry_presets(self):
        try:
            update_type_registries()
            return True
        except Exception:
            return False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="substrateinterface.SubstrateInterface.chain"><code class="name">var <span class="ident">chain</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chain(self):
    if self.__chain is None:
        self.__chain = self.rpc_request(&#34;system_chain&#34;, []).get(&#39;result&#39;)
    return self.__chain</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    if self.__name is None:
        self.__name = self.rpc_request(&#34;system_name&#34;, []).get(&#39;result&#39;)
    return self.__name</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    if self.__properties is None:
        self.__properties = self.rpc_request(&#34;system_properties&#34;, []).get(&#39;result&#39;)
    return self.__properties</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.ss58_format"><code class="name">var <span class="ident">ss58_format</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ss58_format(self):
    if self.__ss58_format is None:
        if self.properties:
            self.__ss58_format = self.properties.get(&#39;ss58Format&#39;)
        else:
            self.__ss58_format = 42
    return self.__ss58_format</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.token_decimals"><code class="name">var <span class="ident">token_decimals</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def token_decimals(self):
    if self.__token_decimals is None:
        self.__token_decimals = self.properties.get(&#39;tokenDecimals&#39;)
    return self.__token_decimals</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.token_symbol"><code class="name">var <span class="ident">token_symbol</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def token_symbol(self):
    if self.__token_symbol is None:
        if self.properties:
            self.__token_symbol = self.properties.get(&#39;tokenSymbol&#39;)
        else:
            self.__token_symbol = &#39;UNIT&#39;
    return self.__token_symbol</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self):
    if self.__version is None:
        self.__version = self.rpc_request(&#34;system_version&#34;, []).get(&#39;result&#39;)
    return self.__version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="substrateinterface.SubstrateInterface.compose_call"><code class="name flex">
<span>def <span class="ident">compose_call</span></span>(<span>self, call_module, call_function, call_params=(), block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Composes a call payload which can be used as an unsigned extrinsic or a proposal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>call_module</code></strong> :&ensp;<code>Name</code> of <code>the runtime module e.g. Balances</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>call_function</code></strong> :&ensp;<code>Name</code> of <code>the call function e.g. transfer</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>call_params</code></strong> :&ensp;<code>This is a dict containing the params</code> of <code>the call. e.g. </code>{'dest': 'EaG2CRhJWPb7qmdcJvy3LiWdh26Jreu9Dx6R1rXxPmYXoDk', 'value': 1000000000000}``</dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong> :&ensp;<code>Use metadata at given block_hash to compose call</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>GenericCall</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose_call(self, call_module, call_function, call_params=(), block_hash=None):
    &#34;&#34;&#34;
    Composes a call payload which can be used as an unsigned extrinsic or a proposal.

    Parameters
    ----------
    call_module: Name of the runtime module e.g. Balances
    call_function: Name of the call function e.g. transfer
    call_params: This is a dict containing the params of the call. e.g. `{&#39;dest&#39;: &#39;EaG2CRhJWPb7qmdcJvy3LiWdh26Jreu9Dx6R1rXxPmYXoDk&#39;, &#39;value&#39;: 1000000000000}`
    block_hash: Use metadata at given block_hash to compose call

    Returns
    -------
    GenericCall
    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    call = ScaleDecoder.get_decoder_class(
        type_string=&#39;Call&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
    )

    call.encode({
        &#39;call_module&#39;: call_module,
        &#39;call_function&#39;: call_function,
        &#39;call_args&#39;: call_params
    })

    return call</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.connect_websocket"><code class="name flex">
<span>def <span class="ident">connect_websocket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_websocket(self):
    if self.url and (self.url[0:6] == &#39;wss://&#39; or self.url[0:5] == &#39;ws://&#39;):
        self.debug_message(&#34;Connecting to {} ...&#34;.format(self.url))
        self.websocket = create_connection(
            self.url,
            max_size=2 ** 32,
            read_limit=2 ** 32,
            write_limit=2 ** 32,
        )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.convert_storage_parameter"><code class="name flex">
<span>def <span class="ident">convert_storage_parameter</span></span>(<span>self, scale_type, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_storage_parameter(self, scale_type, value):
    if scale_type == &#39;AccountId&#39;:
        if value[0:2] != &#39;0x&#39;:
            return &#39;0x{}&#39;.format(ss58_decode(value, self.ss58_format))

    return value</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.create_signed_extrinsic"><code class="name flex">
<span>def <span class="ident">create_signed_extrinsic</span></span>(<span>self, call, keypair: <a title="substrateinterface.base.Keypair" href="base.html#substrateinterface.base.Keypair">Keypair</a>, era=None, nonce=None, tip=0, signature=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a extrinsic signed by given account details</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>call</code></strong> :&ensp;<code>GenericCall to create extrinsic for</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>keypair</code></strong> :&ensp;<code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a> used to sign the extrinsic</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>era</code></strong> :&ensp;<code>Specify mortality in blocks in follow format: {'period': &lt;amount_blocks&gt;} If omitted the extrinsic is immortal</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code>nonce to include in extrinsics, if omitted the current nonce is retrieved on-chain</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>tip</code></strong> :&ensp;<code>specify tip to gain priority during network congestion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>signature</code></strong> :&ensp;<code>Optionally provide signature if externally signed</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ExtrinsicsDecoder The signed Extrinsic</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_signed_extrinsic(self, call, keypair: Keypair, era=None, nonce=None, tip=0, signature=None):
    &#34;&#34;&#34;
    Creates a extrinsic signed by given account details

    Parameters
    ----------
    call: GenericCall to create extrinsic for
    keypair: Keypair used to sign the extrinsic
    era: Specify mortality in blocks in follow format: {&#39;period&#39;: &lt;amount_blocks&gt;} If omitted the extrinsic is immortal
    nonce: nonce to include in extrinsics, if omitted the current nonce is retrieved on-chain
    tip: specify tip to gain priority during network congestion
    signature: Optionally provide signature if externally signed

    Returns
    -------
    ExtrinsicsDecoder The signed Extrinsic
    &#34;&#34;&#34;

    # Check requirements
    if not isinstance(call, GenericCall):
        raise TypeError(&#34;&#39;call&#39; must be of type Call&#34;)

    # Retrieve nonce
    if nonce is None:
        nonce = self.get_account_nonce(keypair.public_key) or 0

    # Process era
    if era is None:
        era = &#39;00&#39;
    else:
        if isinstance(era, dict) and &#39;current&#39; not in era and &#39;phase&#39; not in era:
            # Retrieve current block id
            era[&#39;current&#39;] = self.get_block_number(self.get_chain_finalised_head())

    if signature is not None:

        signature = signature.replace(&#39;0x&#39;, &#39;&#39;)

        # Check if signature is a MultiSignature and contains signature version
        if len(signature) == 130:
            signature_version = int(signature[0:2], 16)
            signature = &#39;0x{}&#39;.format(signature[2:])
        else:
            signature_version = keypair.crypto_type

    else:
        # Create signature payload
        signature_payload = self.generate_signature_payload(call=call, era=era, nonce=nonce, tip=tip)

        # Set Signature version to crypto type of keypair
        signature_version = keypair.crypto_type

        # Sign payload
        signature = keypair.sign(signature_payload)

    # Create extrinsic
    extrinsic = ScaleDecoder.get_decoder_class(
        type_string=&#39;Extrinsic&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
    )

    extrinsic.encode({
        &#39;account_id&#39;: keypair.public_key,
        &#39;signature_version&#39;: signature_version,
        &#39;signature&#39;: signature,
        &#39;call_function&#39;: call.value[&#39;call_function&#39;],
        &#39;call_module&#39;: call.value[&#39;call_module&#39;],
        &#39;call_args&#39;: call.value[&#39;call_args&#39;],
        &#39;nonce&#39;: nonce,
        &#39;era&#39;: era,
        &#39;tip&#39;: tip
    })

    # Set extrinsic hash
    extrinsic.extrinsic_hash = extrinsic.generate_hash()

    return extrinsic</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.create_unsigned_extrinsic"><code class="name flex">
<span>def <span class="ident">create_unsigned_extrinsic</span></span>(<span>self, call)</span>
</code></dt>
<dd>
<div class="desc"><p>Create unsigned extrinsic for given <code>Call</code>
Parameters</p>
<hr>
<dl>
<dt><strong><code>call</code></strong> :&ensp;<code>GenericCall the call the extrinsic should contain</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ExtrinsicsDecoder</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_unsigned_extrinsic(self, call):
    &#34;&#34;&#34;
    Create unsigned extrinsic for given `Call`
    Parameters
    ----------
    call: GenericCall the call the extrinsic should contain

    Returns
    -------
    ExtrinsicsDecoder
    &#34;&#34;&#34;
    # Create extrinsic
    extrinsic = ScaleDecoder.get_decoder_class(
        type_string=&#39;Extrinsic&#39;, metadata=self.metadata_decoder, runtime_config=self.runtime_config
    )

    extrinsic.encode({
        &#39;call_function&#39;: call.value[&#39;call_function&#39;],
        &#39;call_module&#39;: call.value[&#39;call_module&#39;],
        &#39;call_args&#39;: call.value[&#39;call_args&#39;]
    })

    return extrinsic</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.debug_message"><code class="name flex">
<span>def <span class="ident">debug_message</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_message(self, message):
    logger.debug(message)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.decode_scale"><code class="name flex">
<span>def <span class="ident">decode_scale</span></span>(<span>self, type_string, scale_bytes, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to decode arbitrary SCALE-bytes (e.g. 0x02000000) according to given RUST type_string
(e.g. BlockNumber). The relevant versioning information of the type (if defined) will be applied if block_hash
is set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>scale_bytes</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_scale(self, type_string, scale_bytes, block_hash=None):
    &#34;&#34;&#34;
    Helper function to decode arbitrary SCALE-bytes (e.g. 0x02000000) according to given RUST type_string
    (e.g. BlockNumber). The relevant versioning information of the type (if defined) will be applied if block_hash
    is set

    Parameters
    ----------
    type_string
    scale_bytes
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    if type(scale_bytes) == str:
        scale_bytes = ScaleBytes(scale_bytes)

    obj = ScaleDecoder.get_decoder_class(
        type_string=type_string,
        data=scale_bytes,
        metadata=self.metadata_decoder,
        runtime_config=self.runtime_config
    )
    return obj.decode()</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.encode_scale"><code class="name flex">
<span>def <span class="ident">encode_scale</span></span>(<span>self, type_string, value, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to encode arbitrary data into SCALE-bytes for given RUST type_string</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>value</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_scale(self, type_string, value, block_hash=None):
    &#34;&#34;&#34;
    Helper function to encode arbitrary data into SCALE-bytes for given RUST type_string

    Parameters
    ----------
    type_string
    value
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    obj = ScaleDecoder.get_decoder_class(
        type_string=type_string, metadata=self.metadata_decoder, runtime_config=self.runtime_config
    )
    return obj.encode(value)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.generate_signature_payload"><code class="name flex">
<span>def <span class="ident">generate_signature_payload</span></span>(<span>self, call, era=None, nonce=0, tip=0, include_call_length=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_signature_payload(self, call, era=None, nonce=0, tip=0, include_call_length=False):

    # Retrieve genesis hash
    genesis_hash = self.get_block_hash(0)

    if not era:
        era = &#39;00&#39;

    if era == &#39;00&#39;:
        block_hash = genesis_hash
    else:
        era_obj = ScaleDecoder.get_decoder_class(&#39;Era&#39;, runtime_config=self.runtime_config)

        if isinstance(era, dict) and &#39;current&#39; not in era and &#39;phase&#39; not in era:
            raise ValueError(&#39;The era dict must contain either &#34;current&#34; or &#34;phase&#34; element to encode a valid era&#39;)

        era_obj.encode(era)
        block_hash = self.get_block_hash(block_id=era_obj.birth(era.get(&#39;current&#39;)))

    # Create signature payload
    signature_payload = ScaleDecoder.get_decoder_class(&#39;ExtrinsicPayloadValue&#39;, runtime_config=self.runtime_config)

    if include_call_length:

        length_obj = self.runtime_config.get_decoder_class(&#39;Bytes&#39;)
        call_data = str(length_obj().encode(str(call.data)))

    else:
        call_data = str(call.data)

    payload_dict = {
        &#39;call&#39;: call_data,
        &#39;era&#39;: era,
        &#39;nonce&#39;: nonce,
        &#39;tip&#39;: tip,
        &#39;specVersion&#39;: self.runtime_version,
        &#39;genesisHash&#39;: genesis_hash,
        &#39;blockHash&#39;: block_hash
    }

    if self.transaction_version is not None:
        payload_dict[&#39;transactionVersion&#39;] = self.transaction_version

    signature_payload.encode(payload_dict)

    if signature_payload.data.length &gt; 256:
        return ScaleBytes(data=blake2b(signature_payload.data.data, digest_size=32).digest())

    return signature_payload.data</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.generate_storage_hash"><code class="name flex">
<span>def <span class="ident">generate_storage_hash</span></span>(<span>self, storage_module, storage_function, params=None, hasher=None, key2_hasher=None, metadata_version=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a storage key for given module/function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>storage_module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>storage_function</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Parameters</code> of <code>the storage function, provided in scale encoded hex-bytes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>hasher</code></strong> :&ensp;<code>Hashing method used to determine storage key, defaults to 'Twox64Concat' if not provided</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_version</code></strong> :&ensp;<code>Version index</code> of <code>Metadata, e.g. 9 for MetadataV9</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_storage_hash(self, storage_module, storage_function, params=None, hasher=None, key2_hasher=None, metadata_version=None):
    &#34;&#34;&#34;
    Generate a storage key for given module/function

    Parameters
    ----------
    storage_module
    storage_function
    params: Parameters of the storage function, provided in scale encoded hex-bytes
    hasher: Hashing method used to determine storage key, defaults to &#39;Twox64Concat&#39; if not provided
    metadata_version: Version index of Metadata, e.g. 9 for MetadataV9

    Returns
    -------

    &#34;&#34;&#34;

    if not metadata_version or metadata_version &gt;= 9:
        storage_hash = xxh128(storage_module.encode()) + xxh128(storage_function.encode())

        if params:

            if type(params) is not list:
                params = [params]

            for idx, param in enumerate(params):
                if idx == 0:
                    param_hasher = hasher
                elif idx == 1:
                    param_hasher = key2_hasher
                else:
                    raise ValueError(&#39;Unexpected third parameter for storage call&#39;)

                params_key = bytes()

                if type(param) is str:
                    params_key += binascii.unhexlify(param)
                elif type(param) is ScaleBytes:
                    params_key += param.data
                elif isinstance(param, ScaleDecoder):
                    params_key += param.data.data

                if not param_hasher:
                    param_hasher = &#39;Twox128&#39;

                if param_hasher == &#39;Blake2_256&#39;:
                    storage_hash += blake2_256(params_key)

                elif param_hasher == &#39;Blake2_128&#39;:
                    storage_hash += blake2_128(params_key)

                elif param_hasher == &#39;Blake2_128Concat&#39;:
                    storage_hash += blake2_128_concat(params_key)

                elif param_hasher == &#39;Twox128&#39;:
                    storage_hash += xxh128(params_key)

                elif param_hasher == &#39;Twox64Concat&#39;:
                    storage_hash += two_x64_concat(params_key)

                elif param_hasher == &#39;Identity&#39;:
                    storage_hash += identity(params_key)

                else:
                    raise ValueError(&#39;Unknown storage hasher &#34;{}&#34;&#39;.format(param_hasher))

        return &#39;0x{}&#39;.format(storage_hash)

    else:
        storage_hash = storage_module.encode() + b&#34; &#34; + storage_function.encode()

        if params:
            storage_hash += binascii.unhexlify(params)

        # Determine hasher function
        if not hasher:
            hasher = &#39;Twox128&#39;

        if hasher == &#39;Blake2_256&#39;:
            return &#34;0x{}&#34;.format(blake2_256(storage_hash))

        elif hasher == &#39;Twox128&#39;:
            return &#34;0x{}&#34;.format(xxh128(storage_hash))

        elif hasher == &#39;Twox64Concat&#39;:
            return &#34;0x{}&#34;.format(two_x64_concat(storage_hash))</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_account_nonce"><code class="name flex">
<span>def <span class="ident">get_account_nonce</span></span>(<span>self, account_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns current nonce for given account address</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>account_address</code></strong> :&ensp;<code>SS58 formatted address</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_account_nonce(self, account_address):
    &#34;&#34;&#34;
    Returns current nonce for given account address

    Parameters
    ----------
    account_address: SS58 formatted address

    Returns
    -------
    int
    &#34;&#34;&#34;
    account_info = self.query(&#39;System&#39;, &#39;Account&#39;, [account_address])
    if account_info:
        return account_info.value.get(&#39;nonce&#39;, 0)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_events"><code class="name flex">
<span>def <span class="ident">get_block_events</span></span>(<span>self, block_hash, metadata_decoder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience method to fetch the undecoded events from storage</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_decoder</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_events(self, block_hash, metadata_decoder=None):
    &#34;&#34;&#34;
    A convenience method to fetch the undecoded events from storage

    Parameters
    ----------
    block_hash
    metadata_decoder

    Returns
    -------

    &#34;&#34;&#34;

    if metadata_decoder and metadata_decoder.version.index &gt;= 9:
        storage_hash = STORAGE_HASH_SYSTEM_EVENTS_V9
    else:
        storage_hash = STORAGE_HASH_SYSTEM_EVENTS

    response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

    if response.get(&#39;result&#39;):

        if metadata_decoder:
            # Process events
            events_decoder = EventsDecoder(
                data=ScaleBytes(response.get(&#39;result&#39;)),
                metadata=metadata_decoder,
                runtime_config=self.runtime_config
            )
            events_decoder.decode()

            return events_decoder

        else:
            return response
    else:
        raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_extrinsics"><code class="name flex">
<span>def <span class="ident">get_block_extrinsics</span></span>(<span>self, block_hash: str = None, block_id: int = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of <code>Extrinsic</code> objects for given block_hash or block_id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_extrinsics(self, block_hash: str = None, block_id: int = None) -&gt; list:
    &#34;&#34;&#34;
    Retrieves a list of `Extrinsic` objects for given block_hash or block_id

    Parameters
    ----------
    block_hash
    block_id

    Returns
    -------
    list
    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash, block_id=block_id)

    response = self.rpc_request(&#34;chain_getBlock&#34;, [self.block_hash]).get(&#39;result&#39;)

    if response is None:
        raise BlockHashNotFound(f&#34;{block_hash} not found&#34;)

    extrinsics = []

    for extrinsic_data in response[&#39;block&#39;][&#39;extrinsics&#39;]:
        extrinsic = Extrinsic(
            data=ScaleBytes(extrinsic_data),
            metadata=self.metadata_decoder,
            runtime_config=self.runtime_config
        )
        extrinsic.decode()
        extrinsics.append(extrinsic)

    return extrinsics</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_hash"><code class="name flex">
<span>def <span class="ident">get_block_hash</span></span>(<span>self, block_id)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>chain_getBlockHash</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_hash(self, block_id):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `chain_getBlockHash`

    Parameters
    ----------
    block_id

    Returns
    -------

    &#34;&#34;&#34;
    return self.rpc_request(&#34;chain_getBlockHash&#34;, [block_id]).get(&#39;result&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_header"><code class="name flex">
<span>def <span class="ident">get_block_header</span></span>(<span>self, block_hash)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>chain_getHeader</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_header(self, block_hash):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `chain_getHeader`

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    response = self.rpc_request(&#34;chain_getHeader&#34;, [block_hash])
    return response.get(&#39;result&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_metadata"><code class="name flex">
<span>def <span class="ident">get_block_metadata</span></span>(<span>self, block_hash=None, decode=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>state_getMetadata</code>. For a decoded version see <code>get_runtime_metadata()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>decode</code></strong> :&ensp;<code>DEPRECATED use </code>get_runtime_metadata()<code> for decoded version</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_metadata(self, block_hash=None, decode=True):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `state_getMetadata`. For a decoded version see `get_runtime_metadata()`

    Parameters
    ----------
    block_hash
    decode: DEPRECATED use `get_runtime_metadata()` for decoded version

    Returns
    -------

    &#34;&#34;&#34;
    params = None
    if block_hash:
        params = [block_hash]
    response = self.rpc_request(&#34;state_getMetadata&#34;, params)

    if decode:
        metadata_decoder = MetadataDecoder(ScaleBytes(response.get(&#39;result&#39;)))
        metadata_decoder.decode()

        return metadata_decoder

    return response</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_number"><code class="name flex">
<span>def <span class="ident">get_block_number</span></span>(<span>self, block_hash)</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience method to get the block number for given block_hash</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_number(self, block_hash):
    &#34;&#34;&#34;
    A convenience method to get the block number for given block_hash

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    response = self.rpc_request(&#34;chain_getHeader&#34;, [block_hash])
    return int(response[&#39;result&#39;][&#39;number&#39;], 16)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_block_runtime_version"><code class="name flex">
<span>def <span class="ident">get_block_runtime_version</span></span>(<span>self, block_hash)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the runtime version id of given block_hash
Parameters</p>
<hr>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_runtime_version(self, block_hash):
    &#34;&#34;&#34;
    Retrieve the runtime version id of given block_hash
    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    response = self.rpc_request(&#34;chain_getRuntimeVersion&#34;, [block_hash])
    return response.get(&#39;result&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_chain_block"><code class="name flex">
<span>def <span class="ident">get_chain_block</span></span>(<span>self, block_hash=None, block_id=None, metadata_decoder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>chain_getBlock</code>. For a decoded version see <code>get_runtime_block()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_id</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_decoder</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_block(self, block_hash=None, block_id=None, metadata_decoder=None):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `chain_getBlock`. For a decoded version see `get_runtime_block()`

    Parameters
    ----------
    block_hash
    block_id
    metadata_decoder

    Returns
    -------

    &#34;&#34;&#34;

    if block_id:
        block_hash = self.get_block_hash(block_id)

    response = self.rpc_request(&#34;chain_getBlock&#34;, [block_hash]).get(&#39;result&#39;)

    if self.mock_extrinsics:
        # Extend extrinsics with mock_extrinsics for e.g. performance tests
        response[&#39;block&#39;][&#39;extrinsics&#39;].extend(self.mock_extrinsics)

    # Decode extrinsics
    if metadata_decoder:

        response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;] = int(response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;], 16)

        for idx, extrinsic_data in enumerate(response[&#39;block&#39;][&#39;extrinsics&#39;]):
            extrinsic_decoder = ExtrinsicsDecoder(
                data=ScaleBytes(extrinsic_data),
                metadata=metadata_decoder,
                runtime_config=self.runtime_config
            )
            extrinsic_decoder.decode()
            response[&#39;block&#39;][&#39;extrinsics&#39;][idx] = extrinsic_decoder.value

        for idx, log_data in enumerate(response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;]):
            log_digest = LogDigest(ScaleBytes(log_data), runtime_config=self.runtime_config)
            log_digest.decode()
            response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;][idx] = log_digest.value

    return response</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_chain_finalised_head"><code class="name flex">
<span>def <span class="ident">get_chain_finalised_head</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>chain_getFinalisedHead</code></p>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_finalised_head(self):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `chain_getFinalisedHead`

    Returns
    -------

    &#34;&#34;&#34;
    response = self.rpc_request(&#34;chain_getFinalisedHead&#34;, [])
    return response.get(&#39;result&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_chain_head"><code class="name flex">
<span>def <span class="ident">get_chain_head</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>chain_getHead</code></p>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_head(self):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `chain_getHead`

    Returns
    -------

    &#34;&#34;&#34;
    response = self.rpc_request(&#34;chain_getHead&#34;, [])
    return response.get(&#39;result&#39;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_events"><code class="name flex">
<span>def <span class="ident">get_events</span></span>(<span>self, block_hash=None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to get events for a certain block (storage call for module 'System' and function 'Events')</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_events(self, block_hash=None) -&gt; list:
    &#34;&#34;&#34;
    Convenience method to get events for a certain block (storage call for module &#39;System&#39; and function &#39;Events&#39;)

    Parameters
    ----------
    block_hash

    Returns
    -------
    list
    &#34;&#34;&#34;
    events = []
    storage_obj = self.query(module=&#34;System&#34;, storage_function=&#34;Events&#34;, block_hash=block_hash)
    if storage_obj:
        events += storage_obj.elements
    return events</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_call_function"><code class="name flex">
<span>def <span class="ident">get_metadata_call_function</span></span>(<span>self, module_name, call_function_name, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the details of a call function given module name, call function name and block_hash
(or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>call_function_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_call_function(self, module_name, call_function_name, block_hash=None):
    &#34;&#34;&#34;
    Retrieves the details of a call function given module name, call function name and block_hash
    (or chaintip if block_hash is omitted)

    Parameters
    ----------
    module_name
    call_function_name
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    result = None

    for call_index, (module, call) in self.metadata_decoder.call_index.items():
        if module.name == module_name and \
                call.get_identifier() == call_function_name:
            result = self.serialize_module_call(
                module, call, self.runtime_version, call_index
            )
            break

    return result</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_call_functions"><code class="name flex">
<span>def <span class="ident">get_metadata_call_functions</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all call functions in metadata active for given block_hash (or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_call_functions(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of all call functions in metadata active for given block_hash (or chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    call_list = []

    for call_index, (module, call) in self.metadata_decoder.call_index.items():
        call_list.append(
            self.serialize_module_call(
                module, call, self.runtime_version, call_index
            )
        )
    return call_list</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_constant"><code class="name flex">
<span>def <span class="ident">get_metadata_constant</span></span>(<span>self, module_name, constant_name, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the details of a constant for given module name, call function name and block_hash
(or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>constant_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_constant(self, module_name, constant_name, block_hash=None):
    &#34;&#34;&#34;
    Retrieves the details of a constant for given module name, call function name and block_hash
    (or chaintip if block_hash is omitted)

    Parameters
    ----------
    module_name
    constant_name
    block_hash

    Returns
    -------

    &#34;&#34;&#34;

    self.init_runtime(block_hash=block_hash)

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):

        if module_name == module.name and module.constants:

            for constant in module.constants:
                if constant_name == constant.name:
                    return self.serialize_constant(
                        constant, module, self.runtime_version
                    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_constants"><code class="name flex">
<span>def <span class="ident">get_metadata_constants</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all constants in metadata active at given block_hash (or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_constants(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of all constants in metadata active at given block_hash (or chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;

    self.init_runtime(block_hash=block_hash)

    constant_list = []

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
        for constant in module.constants or []:
            constant_list.append(
                self.serialize_constant(
                    constant, module, self.runtime_version
                )
            )

    return constant_list</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_error"><code class="name flex">
<span>def <span class="ident">get_metadata_error</span></span>(<span>self, module_name, error_name, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the details of an error for given module name, call function name and block_hash</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>error_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_error(self, module_name, error_name, block_hash=None):
    &#34;&#34;&#34;
    Retrieves the details of an error for given module name, call function name and block_hash

    Parameters
    ----------
    module_name
    error_name
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
        if module.name == module_name and module.errors:
            for error in module.errors:
                if error_name == error.name:
                    return self.serialize_module_error(
                        module=module, error=error, spec_version=self.runtime_version
                    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_errors"><code class="name flex">
<span>def <span class="ident">get_metadata_errors</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all errors in metadata active at given block_hash (or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_errors(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of all errors in metadata active at given block_hash (or chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    error_list = []

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
        if module.errors:
            for error in module.errors:
                error_list.append(
                    self.serialize_module_error(
                        module=module, error=error, spec_version=self.runtime_version
                    )
                )

    return error_list</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_event"><code class="name flex">
<span>def <span class="ident">get_metadata_event</span></span>(<span>self, module_name, event_name, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the details of an event for given module name, call function name and block_hash
(or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>event_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_event(self, module_name, event_name, block_hash=None):
    &#34;&#34;&#34;
    Retrieves the details of an event for given module name, call function name and block_hash
    (or chaintip if block_hash is omitted)

    Parameters
    ----------
    module_name
    event_name
    block_hash

    Returns
    -------

    &#34;&#34;&#34;

    self.init_runtime(block_hash=block_hash)

    for event_index, (module, event) in self.metadata_decoder.event_index.items():
        if module.name == module_name and \
                event.name == event_name:
            return self.serialize_module_event(
                module, event, self.runtime_version, event_index
            )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_events"><code class="name flex">
<span>def <span class="ident">get_metadata_events</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all events in metadata active for given block_hash (or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_events(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of all events in metadata active for given block_hash (or chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;

    self.init_runtime(block_hash=block_hash)

    event_list = []

    for event_index, (module, event) in self.metadata_decoder.event_index.items():
        event_list.append(
            self.serialize_module_event(
                module, event, self.runtime_version, event_index
            )
        )

    return event_list</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_modules"><code class="name flex">
<span>def <span class="ident">get_metadata_modules</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of modules in metadata for given block_hash (or chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_modules(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of modules in metadata for given block_hash (or chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    return [{
        &#39;metadata_index&#39;: idx,
        &#39;module_id&#39;: module.get_identifier(),
        &#39;name&#39;: module.name,
        &#39;prefix&#39;: module.prefix,
        &#39;spec_version&#39;: self.runtime_version,
        &#39;count_call_functions&#39;: len(module.calls or []),
        &#39;count_storage_functions&#39;: len(module.calls or []),
        &#39;count_events&#39;: len(module.events or []),
        &#39;count_constants&#39;: len(module.constants or []),
        &#39;count_errors&#39;: len(module.errors or []),
    } for idx, module in enumerate(self.metadata_decoder.metadata.modules)]</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_storage_function"><code class="name flex">
<span>def <span class="ident">get_metadata_storage_function</span></span>(<span>self, module_name, storage_name, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the details of a storage function for given module name, call function name and block_hash</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>storage_name</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_storage_function(self, module_name, storage_name, block_hash=None):
    &#34;&#34;&#34;
    Retrieves the details of a storage function for given module name, call function name and block_hash

    Parameters
    ----------
    module_name
    storage_name
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
        if module.name == module_name and module.storage:
            for storage in module.storage.items:
                if storage.name == storage_name:
                    return self.serialize_storage_item(
                        storage_item=storage,
                        module=module,
                        spec_version_id=self.runtime_version
                    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_metadata_storage_functions"><code class="name flex">
<span>def <span class="ident">get_metadata_storage_functions</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all storage functions in metadata active at given block_hash (or chaintip if block_hash is
omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata_storage_functions(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves a list of all storage functions in metadata active at given block_hash (or chaintip if block_hash is
    omitted)

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    storage_list = []

    for module_idx, module in enumerate(self.metadata_decoder.metadata.modules):
        if module.storage:
            for storage in module.storage.items:
                storage_list.append(
                    self.serialize_storage_item(
                        storage_item=storage,
                        module=module,
                        spec_version_id=self.runtime_version
                    )
                )

    return storage_list</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_payment_info"><code class="name flex">
<span>def <span class="ident">get_payment_info</span></span>(<span>self, call, keypair)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves fee estimation via RPC for given extrinsic</p>
<h2 id="parameters">Parameters</h2>
<p>call Call object to estimate fees for
keypair Keypair of the sender, does not have to include private key because no valid signature is required</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict with payment info</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>E.g. <code>{'class': 'normal', 'partialFee': 151000000, 'weight': 217238000}</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payment_info(self, call, keypair):
    &#34;&#34;&#34;
    Retrieves fee estimation via RPC for given extrinsic

    Parameters
    ----------
    call Call object to estimate fees for
    keypair Keypair of the sender, does not have to include private key because no valid signature is required

    Returns
    -------
    Dict with payment info

    E.g. `{&#39;class&#39;: &#39;normal&#39;, &#39;partialFee&#39;: 151000000, &#39;weight&#39;: 217238000}`

    &#34;&#34;&#34;

    # Check requirements
    if not isinstance(call, GenericCall):
        raise TypeError(&#34;&#39;call&#39; must be of type Call&#34;)

    if not isinstance(keypair, Keypair):
        raise TypeError(&#34;&#39;keypair&#39; must be of type Keypair&#34;)

    # No valid signature is required for fee estimation
    signature = &#39;0x&#39; + &#39;00&#39; * 64

    # Create extrinsic
    extrinsic = self.create_signed_extrinsic(
        call=call,
        keypair=keypair,
        signature=signature
    )

    payment_info = self.rpc_request(&#39;payment_queryInfo&#39;, [str(extrinsic.data)])

    # convert partialFee to int
    if &#39;result&#39; in payment_info:
        payment_info[&#39;result&#39;][&#39;partialFee&#39;] = int(payment_info[&#39;result&#39;][&#39;partialFee&#39;])
        return payment_info[&#39;result&#39;]
    else:
        raise SubstrateRequestException(payment_info[&#39;error&#39;][&#39;message&#39;])</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_runtime_block"><code class="name flex">
<span>def <span class="ident">get_runtime_block</span></span>(<span>self, block_hash=None, block_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a block with method <code>chain_getBlock</code> and in addition decodes extrinsics and log items</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_block(self, block_hash=None, block_id=None):
    &#34;&#34;&#34;
    Retrieves a block with method `chain_getBlock` and in addition decodes extrinsics and log items

    Parameters
    ----------
    block_hash
    block_id

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash, block_id=block_id)

    response = self.rpc_request(&#34;chain_getBlock&#34;, [self.block_hash]).get(&#39;result&#39;)

    if response:
        response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;] = int(response[&#39;block&#39;][&#39;header&#39;][&#39;number&#39;], 16)

        for idx, extrinsic_data in enumerate(response[&#39;block&#39;][&#39;extrinsics&#39;]):
            extrinsic_decoder = Extrinsic(
                data=ScaleBytes(extrinsic_data),
                metadata=self.metadata_decoder,
                runtime_config=self.runtime_config
            )
            extrinsic_decoder.decode()
            response[&#39;block&#39;][&#39;extrinsics&#39;][idx] = extrinsic_decoder.value

        for idx, log_data in enumerate(response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;]):
            log_digest = LogDigest(ScaleBytes(log_data), runtime_config=self.runtime_config)
            log_digest.decode()
            response[&#39;block&#39;][&#39;header&#39;][&#34;digest&#34;][&#34;logs&#34;][idx] = log_digest.value

    return response</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_runtime_events"><code class="name flex">
<span>def <span class="ident">get_runtime_events</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_events(self, block_hash=None):

    warnings.warn(&#34;&#39;get_runtime_events&#39; will be replaced by &#39;get_events&#39;&#34;, DeprecationWarning)

    &#34;&#34;&#34;
    Convenience method to get events for a certain block (storage call for module &#39;System&#39; and function &#39;Events&#39;)

    Parameters
    ----------
    block_hash

    Returns
    -------
    Collection of events
    &#34;&#34;&#34;
    return self.get_runtime_state(
        module=&#34;System&#34;,
        storage_function=&#34;Events&#34;,
        block_hash=block_hash
    )</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_runtime_metadata"><code class="name flex">
<span>def <span class="ident">get_runtime_metadata</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves and decodes the metadata for given block or chaintip if block_hash is omitted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_metadata(self, block_hash=None):
    &#34;&#34;&#34;
    Retrieves and decodes the metadata for given block or chaintip if block_hash is omitted.

    Parameters
    ----------
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    params = None
    if block_hash:
        params = [block_hash]
    response = self.rpc_request(&#34;state_getMetadata&#34;, params)

    if &#39;result&#39; in response:
        metadata_decoder = MetadataDecoder(ScaleBytes(response.get(&#39;result&#39;)))
        response[&#39;result&#39;] = metadata_decoder.decode()

    return response</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_runtime_state"><code class="name flex">
<span>def <span class="ident">get_runtime_state</span></span>(<span>self, module, storage_function, params=None, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_state(self, module, storage_function, params=None, block_hash=None):
    warnings.warn(&#34;&#39;get_runtime_state&#39; will be replaced by &#39;query&#39;&#34;, DeprecationWarning)

    obj = self.query(module, storage_function, params=params, block_hash=block_hash)
    return {&#39;result&#39;: obj.value if obj else None}</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_storage"><code class="name flex">
<span>def <span class="ident">get_storage</span></span>(<span>self, block_hash, module, function, params=None, return_scale_type=None, hasher=None, spec_version_id='default', metadata=None, metadata_version=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the storage entry for given module, function and optional parameters at given block.</p>
<p>DEPRECATED: use <code>get_runtime_state()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>function</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>return_scale_type</code></strong> :&ensp;<code>Scale type string to interprete result</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>hasher</code></strong> :&ensp;<code>Hashing method used to determine storage key, defaults to 'Twox64Concat' if not provided</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version_id</code></strong> :&ensp;<code>DEPRECATED</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>metadata_version</code></strong> :&ensp;<code>Version index</code> of <code>Metadata, e.g. 9 for MetadataV9</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage(self, block_hash, module, function, params=None, return_scale_type=None, hasher=None,
                spec_version_id=&#39;default&#39;, metadata=None, metadata_version=None):
    &#34;&#34;&#34;
    Retrieves the storage entry for given module, function and optional parameters at given block.

    DEPRECATED: use `get_runtime_state()`

    Parameters
    ----------
    block_hash
    module
    function
    params
    return_scale_type: Scale type string to interprete result
    hasher: Hashing method used to determine storage key, defaults to &#39;Twox64Concat&#39; if not provided
    spec_version_id: DEPRECATED
    metadata
    metadata_version: Version index of Metadata, e.g. 9 for MetadataV9

    Returns
    -------

    &#34;&#34;&#34;
    storage_hash = self.generate_storage_hash(
        storage_module=module,
        storage_function=function,
        params=params,
        hasher=hasher,
        metadata_version=metadata_version
    )
    response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

    if &#39;result&#39; in response:

        if return_scale_type and response.get(&#39;result&#39;):
            obj = ScaleDecoder.get_decoder_class(
                type_string=return_scale_type,
                data=ScaleBytes(response.get(&#39;result&#39;)),
                metadata=metadata,
                runtime_config=self.runtime_config
            )
            return obj.decode()
        else:
            return response.get(&#39;result&#39;)
    else:
        raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_storage_by_key"><code class="name flex">
<span>def <span class="ident">get_storage_by_key</span></span>(<span>self, block_hash, storage_key)</span>
</code></dt>
<dd>
<div class="desc"><p>A pass-though to existing JSONRPC method <code>state_getStorageAt</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>storage_key</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage_by_key(self, block_hash, storage_key):
    &#34;&#34;&#34;
    A pass-though to existing JSONRPC method `state_getStorageAt`

    Parameters
    ----------
    block_hash
    storage_key

    Returns
    -------

    &#34;&#34;&#34;

    response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_key, block_hash])
    if &#39;result&#39; in response:
        return response.get(&#39;result&#39;)
    else:
        raise SubstrateRequestException(&#34;Error occurred during retrieval of events&#34;)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_type_definition"><code class="name flex">
<span>def <span class="ident">get_type_definition</span></span>(<span>self, type_string, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves decoding specifications of given type_string</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong> :&ensp;<code>RUST variable type, e.g. Vec&lt;Address&gt;</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_definition(self, type_string, block_hash=None):
    &#34;&#34;&#34;
    Retrieves decoding specifications of given type_string

    Parameters
    ----------
    type_string: RUST variable type, e.g. Vec&lt;Address&gt;
    block_hash

    Returns
    -------

    &#34;&#34;&#34;
    type_registry = self.get_type_registry(block_hash=block_hash)
    return type_registry.get(type_string.lower())</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.get_type_registry"><code class="name flex">
<span>def <span class="ident">get_type_registry</span></span>(<span>self, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an exhaustive list of which RUST types exist in the runtime specified at given block_hash (or
chaintip if block_hash is omitted)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong> :&ensp;<code>Chaintip will be used if block_hash is omitted</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_registry(self, block_hash=None):
    &#34;&#34;&#34;
    Generates an exhaustive list of which RUST types exist in the runtime specified at given block_hash (or
    chaintip if block_hash is omitted)

    Parameters
    ----------
    block_hash: Chaintip will be used if block_hash is omitted

    Returns
    -------

    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    if self.runtime_version not in self.type_registry_cache:

        for module in self.metadata_decoder.metadata.modules:

            # Storage backwards compt check
            if module.storage and isinstance(module.storage, list):
                storage_functions = module.storage
            elif module.storage and isinstance(getattr(module.storage, &#39;value&#39;), dict):
                storage_functions = module.storage.items
            else:
                storage_functions = []

            if len(module.calls or []) &gt; 0:
                for idx, call in enumerate(module.calls):
                    for arg in call.args:
                        self.process_metadata_typestring(arg.type)

            if len(module.events or []) &gt; 0:
                for event_index, event in enumerate(module.events):

                    for arg_index, arg in enumerate(event.args):
                        self.process_metadata_typestring(arg)

            if len(storage_functions) &gt; 0:
                for idx, storage in enumerate(storage_functions):

                    # Determine type
                    type_key1 = None
                    type_key2 = None
                    type_value = None

                    if storage.type.get(&#39;PlainType&#39;):
                        type_value = storage.type.get(&#39;PlainType&#39;)

                    elif storage.type.get(&#39;MapType&#39;):
                        type_key1 = storage.type[&#39;MapType&#39;].get(&#39;key&#39;)
                        type_value = storage.type[&#39;MapType&#39;].get(&#39;value&#39;)

                    elif storage.type.get(&#39;DoubleMapType&#39;):
                        type_key1 = storage.type[&#39;DoubleMapType&#39;].get(&#39;key1&#39;)
                        type_key2 = storage.type[&#39;DoubleMapType&#39;].get(&#39;key2&#39;)
                        type_value = storage.type[&#39;DoubleMapType&#39;].get(&#39;value&#39;)

                    self.process_metadata_typestring(type_value)

                    if type_key1:
                        self.process_metadata_typestring(type_key1)

                    if type_key2:
                        self.process_metadata_typestring(type_key2)

            if len(module.constants or []) &gt; 0:
                for idx, constant in enumerate(module.constants):

                    # Check if types already registered in database
                    self.process_metadata_typestring(constant.type)

    return self.type_registry_cache[self.runtime_version]</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.init_runtime"><code class="name flex">
<span>def <span class="ident">init_runtime</span></span>(<span>self, block_hash=None, block_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used by all other methods that deals with metadata and types defined in the type registry.
It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that
block_hash. Also it applies all the versioned types at the time of the block_hash.</p>
<p>Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.
In the future there could be support for caching backends like Redis to make this cache more persistent.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>block_hash</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_runtime(self, block_hash=None, block_id=None):
    &#34;&#34;&#34;
    This method is used by all other methods that deals with metadata and types defined in the type registry.
    It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that
    block_hash. Also it applies all the versioned types at the time of the block_hash.

    Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.
    In the future there could be support for caching backends like Redis to make this cache more persistent.

    Parameters
    ----------
    block_hash
    block_id

    Returns
    -------

    &#34;&#34;&#34;

    if block_id and block_hash:
        raise ValueError(&#39;Cannot provide block_hash and block_id at the same time&#39;)

    # Check if runtime state already set to current block
    if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):
        return

    if block_id is not None:
        block_hash = self.get_block_hash(block_id)

    self.block_hash = block_hash
    self.block_id = block_id

    # In fact calls and storage functions are decoded against runtime of previous block, therefor retrieve
    # metadata and apply type registry of runtime of parent block
    block_header = self.get_block_header(block_hash=self.block_hash) or {}
    parent_block_hash = block_header.get(&#39;parentHash&#39;)

    if parent_block_hash == &#39;0x0000000000000000000000000000000000000000000000000000000000000000&#39;:
        runtime_block_hash = self.block_hash
    else:
        runtime_block_hash = parent_block_hash

    runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)

    if runtime_info is None:
        raise SubstrateRequestException(f&#34;No runtime information for block &#39;{block_hash}&#39;&#34;)

    # Check if runtime state already set to current block
    if runtime_info.get(&#34;specVersion&#34;) == self.runtime_version:
        return

    self.runtime_version = runtime_info.get(&#34;specVersion&#34;)
    self.transaction_version = runtime_info.get(&#34;transactionVersion&#34;)

    # Set active runtime version
    self.runtime_config.set_active_spec_version_id(self.runtime_version)

    if self.runtime_version not in self.metadata_cache and self.cache_region:
        # Try to retrieve metadata from Dogpile cache
        cached_metadata = self.cache_region.get(&#39;METADATA_{}&#39;.format(self.runtime_version))
        if cached_metadata:
            self.debug_message(&#39;Retrieved metadata for {} from Redis&#39;.format(self.runtime_version))
            self.metadata_cache[self.runtime_version] = cached_metadata

    if self.runtime_version in self.metadata_cache:
        # Get metadata from cache
        self.debug_message(&#39;Retrieved metadata for {} from memory&#39;.format(self.runtime_version))
        self.metadata_decoder = self.metadata_cache[self.runtime_version]
    else:
        self.metadata_decoder = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)
        self.debug_message(&#39;Retrieved metadata for {} from Substrate node&#39;.format(self.runtime_version))

        # Update metadata cache
        self.metadata_cache[self.runtime_version] = self.metadata_decoder

        if self.cache_region:
            self.debug_message(&#39;Stored metadata for {} in Redis&#39;.format(self.runtime_version))
            self.cache_region.set(&#39;METADATA_{}&#39;.format(self.runtime_version), self.metadata_decoder)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.iterate_map"><code class="name flex">
<span>def <span class="ident">iterate_map</span></span>(<span>self, module, storage_function, block_hash=None)</span>
</code></dt>
<dd>
<div class="desc"><p>iterates over all key-pairs localted at the given module and storage_function. The storage
item must be a map.</p>
<h2 id="parameters">Parameters</h2>
<p>module: The module name in the metadata, e.g. Balances or Account.
storage_function: The storage function name, e.g. FreeBalance or AccountNonce.
block_hash: Optional block hash, when left to None the chain tip will be used.</p>
<h2 id="returns">Returns</h2>
<p>A two dimensional list of key-value pairs, both decoded into the given type, e.g.
[[k1, v1], [k2, v2], &hellip;]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate_map(self, module, storage_function, block_hash=None):
    &#34;&#34;&#34;
    iterates over all key-pairs localted at the given module and storage_function. The storage
    item must be a map.

    Parameters
    ----------
    module: The module name in the metadata, e.g. Balances or Account.
    storage_function: The storage function name, e.g. FreeBalance or AccountNonce.
    block_hash: Optional block hash, when left to None the chain tip will be used.

    Returns
    -------
    A two dimensional list of key-value pairs, both decoded into the given type, e.g.
    [[k1, v1], [k2, v2], ...]
    &#34;&#34;&#34;
    self.init_runtime(block_hash=block_hash)

    key_type = None
    value_type = None
    concat_hash_len = None
    for metadata_module in self.metadata_decoder.metadata.modules:
        if metadata_module.name == module:
            if metadata_module.storage:
                for storage_item in metadata_module.storage.items:
                    if storage_item.name == storage_function:
                        if &#39;MapType&#39; in storage_item.type:
                            key_type = storage_item.type[&#39;MapType&#39;][&#39;key&#39;]
                            value_type = storage_item.type[&#39;MapType&#39;][&#39;value&#39;]
                            if storage_item.type[&#39;MapType&#39;][&#39;hasher&#39;] == &#34;Blake2_128Concat&#34;:
                                concat_hash_len = 32
                            elif storage_item.type[&#39;MapType&#39;][&#39;hasher&#39;] == &#34;Twox64Concat&#34;:
                                concat_hash_len = 16
                            else:
                                raise ValueError(&#39;Unsupported hash type&#39;)
                        else:
                            raise ValueError(&#39;Given storage is not a map&#39;)

    prefix = self.generate_storage_hash(module, storage_function)
    prefix_len = len(prefix)
    pairs = self.rpc_request(method=&#34;state_getPairs&#34;, params=[prefix, block_hash]).get(&#39;result&#39;)

    # convert keys to the portion that needs to be decoded.
    pairs = map(lambda kp: [&#34;0x&#34; + kp[0][prefix_len + concat_hash_len:], kp[1]], pairs)

    # decode both of them
    pairs = map(
        lambda kp: [self.decode_scale(key_type, kp[0]), self.decode_scale(value_type, kp[1])],
        list(pairs)
    )

    return list(pairs)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.process_metadata_typestring"><code class="name flex">
<span>def <span class="ident">process_metadata_typestring</span></span>(<span>self, type_string)</span>
</code></dt>
<dd>
<div class="desc"><p>Process how given type_string is decoded with active runtime and type registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type_string</code></strong> :&ensp;<code>RUST variable type, e.g. </code>Vec<Address>``</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> of <code>properties for given type_string</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>E.g.</p>
<p><code>{
"type_string": "Vec&lt;Address&gt;",
"decoder_class": "Vec",
"is_primitive_runtime": false,
"is_primitive_core": false,
"spec_version": 1030
}</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_metadata_typestring(self, type_string):
    &#34;&#34;&#34;
    Process how given type_string is decoded with active runtime and type registry

    Parameters
    ----------
    type_string: RUST variable type, e.g. `Vec&lt;Address&gt;`

    Returns
    -------

    dict of properties for given type_string

    E.g.

    `{
        &#34;type_string&#34;: &#34;Vec&lt;Address&gt;&#34;,
        &#34;decoder_class&#34;: &#34;Vec&#34;,
        &#34;is_primitive_runtime&#34;: false,
        &#34;is_primitive_core&#34;: false,
        &#34;spec_version&#34;: 1030
    }`

    &#34;&#34;&#34;
    decoder_class_obj = None

    type_info = {
        &#34;type_string&#34;: type_string,
        &#34;decoder_class&#34;: None,
        &#34;is_primitive_runtime&#34;: None,
        &#34;is_primitive_core&#34;: False,
        &#34;spec_version&#34;: self.runtime_version
    }

    if self.runtime_version not in self.type_registry_cache:
        self.type_registry_cache[self.runtime_version] = {}

    # Check if already added
    if type_string.lower() in self.type_registry_cache[self.runtime_version]:
        return self.type_registry_cache[self.runtime_version][type_string.lower()][&#39;decoder_class&#39;]

    # Try to get decoder class
    decoder_class = self.runtime_config.get_decoder_class(type_string)

    if not decoder_class:

        # Not in type registry, try get hard coded decoder classes
        try:
            decoder_class_obj = ScaleDecoder.get_decoder_class(
                type_string=type_string, runtime_config=self.runtime_config
            )
            decoder_class = decoder_class_obj.__class__
        except NotImplementedError as e:
            decoder_class = None

    # Process classes that contain subtypes (e.g. Option&lt;ChangesTrieConfiguration&gt;)
    if decoder_class_obj and decoder_class_obj.sub_type:
        type_info[&#34;is_primitive_runtime&#34;] = False

        # Try to split on &#39;,&#39; (e.g. ActiveRecovery&lt;BlockNumber, BalanceOf, AccountId&gt;)
        if not re.search(&#39;[&lt;()&gt;]&#39;, decoder_class_obj.sub_type):
            for element in decoder_class_obj.sub_type.split(&#39;,&#39;):
                if element not in [&#39;T&#39;, &#39;I&#39;]:
                    self.process_metadata_typestring(element.strip())

    # Process classes that contain type_mapping (e.g. Struct and Enum)
    if decoder_class and hasattr(decoder_class, &#39;type_mapping&#39;) and decoder_class.type_mapping:

        if type_string[0] == &#39;(&#39;:
            type_info[&#34;is_primitive_runtime&#34;] = False

        for key, data_type in decoder_class.type_mapping:
            self.process_metadata_typestring(data_type)

    # Try to get superclass as actual decoding class if not root level &#39;ScaleType&#39;
    if decoder_class and len(decoder_class.__mro__) &gt; 1 and decoder_class.__mro__[1].__name__ != &#39;ScaleType&#39;:
        decoder_class = decoder_class.__mro__[1]

    if decoder_class:
        type_info[&#39;decoder_class&#39;] = decoder_class.__name__

        if type_info[&#34;is_primitive_runtime&#34;] is None:
            type_info[&#34;is_primitive_runtime&#34;] = True

        if type_info[&#34;is_primitive_runtime&#34;] and type_string.lower() in ScaleDecoder.PRIMITIVES:
            type_info[&#34;is_primitive_core&#34;] = True
    else:
        type_info[&#34;is_primitive_runtime&#34;] = None
        type_info[&#34;is_primitive_core&#34;] = None

    self.type_registry_cache[self.runtime_version][type_string.lower()] = type_info

    return decoder_class</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, module, storage_function, params=None, block_hash=None) ‑> Union[scalecodec.base.ScaleType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the storage entry for given module, function and optional parameters at given block hash</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module</code></strong> :&ensp;<code>The module name in the metadata, e.g. Balances</code> or <code>Account</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>storage_function</code></strong> :&ensp;<code>The storage function name, e.g. FreeBalance</code> or <code>AccountNonce</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>list</code> of <code>params, in the decoded format</code> of <code>the applicable ScaleTypes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>block_hash</code></strong> :&ensp;<code>Optional block hash, when omitted the chain tip will be used</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ScaleType</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, module, storage_function, params=None, block_hash=None) -&gt; typing.Optional[ScaleType]:
    &#34;&#34;&#34;
    Retrieves the storage entry for given module, function and optional parameters at given block hash

    Parameters
    ----------
    module: The module name in the metadata, e.g. Balances or Account
    storage_function: The storage function name, e.g. FreeBalance or AccountNonce
    params: list of params, in the decoded format of the applicable ScaleTypes
    block_hash: Optional block hash, when omitted the chain tip will be used

    Returns
    -------
    ScaleType
    &#34;&#34;&#34;

    self.init_runtime(block_hash=block_hash)

    # Search storage call in metadata
    for metadata_module in self.metadata_decoder.metadata.modules:
        if metadata_module.name == module:
            if metadata_module.storage:
                for storage_item in metadata_module.storage.items:
                    if storage_item.name == storage_function:

                        key2_hasher = None

                        if &#39;PlainType&#39; in storage_item.type:
                            hasher = &#39;Twox64Concat&#39;
                            return_scale_type = storage_item.type.get(&#39;PlainType&#39;)
                            if params:
                                raise ValueError(&#39;Storage call of type &#34;PlainType&#34; doesn\&#39;t accept params&#39;)

                        elif &#39;MapType&#39; in storage_item.type:

                            map_type = storage_item.type.get(&#39;MapType&#39;)
                            hasher = map_type.get(&#39;hasher&#39;)
                            return_scale_type = map_type.get(&#39;value&#39;)

                            if not params or len(params) != 1:
                                raise ValueError(&#39;Storage call of type &#34;MapType&#34; requires 1 parameter&#39;)

                            # Encode parameter
                            params[0] = self.convert_storage_parameter(map_type[&#39;key&#39;], params[0])
                            param_obj = ScaleDecoder.get_decoder_class(
                                type_string=map_type[&#39;key&#39;], runtime_config=self.runtime_config
                            )
                            params[0] = param_obj.encode(params[0])

                        elif &#39;DoubleMapType&#39; in storage_item.type:

                            map_type = storage_item.type.get(&#39;DoubleMapType&#39;)
                            hasher = map_type.get(&#39;hasher&#39;)
                            key2_hasher = map_type.get(&#39;key2Hasher&#39;)
                            return_scale_type = map_type.get(&#39;value&#39;)

                            if not params or len(params) != 2:
                                raise ValueError(&#39;Storage call of type &#34;DoubleMapType&#34; requires 2 parameters&#39;)

                            # Encode parameter 1
                            params[0] = self.convert_storage_parameter(map_type[&#39;key1&#39;], params[0])
                            param_obj = ScaleDecoder.get_decoder_class(
                                type_string=map_type[&#39;key1&#39;], runtime_config=self.runtime_config
                            )
                            params[0] = param_obj.encode(params[0])

                            # Encode parameter 2
                            params[1] = self.convert_storage_parameter(map_type[&#39;key2&#39;], params[1])
                            param_obj = ScaleDecoder.get_decoder_class(
                                type_string=map_type[&#39;key2&#39;], runtime_config=self.runtime_config
                            )
                            params[1] = param_obj.encode(params[1])

                        else:
                            raise NotImplementedError(&#34;Storage type not implemented&#34;)

                        storage_hash = self.generate_storage_hash(
                            storage_module=metadata_module.prefix,
                            storage_function=storage_function,
                            params=params,
                            hasher=hasher,
                            key2_hasher=key2_hasher,
                            metadata_version=self.metadata_decoder.version.index
                        )

                        response = self.rpc_request(&#34;state_getStorageAt&#34;, [storage_hash, block_hash])

                        if &#39;result&#39; in response:

                            if return_scale_type and response.get(&#39;result&#39;):
                                obj = ScaleDecoder.get_decoder_class(
                                    type_string=return_scale_type,
                                    data=ScaleBytes(response.get(&#39;result&#39;)),
                                    metadata=self.metadata_decoder,
                                    runtime_config=self.runtime_config
                                )
                                obj.decode()
                                return obj

                        return None

    raise StorageFunctionNotFound(&#39;Storage function &#34;{}.{}&#34; not found&#39;.format(module, storage_function))</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.rpc_request"><code class="name flex">
<span>def <span class="ident">rpc_request</span></span>(<span>self, method, params, result_handler=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that handles the actual RPC request to the Substrate node. The other implemented functions eventually
use this method to perform the request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>result_handler</code></strong> :&ensp;<code>Callback</code> of <code>function that processes the result received from the node</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>method</code> of <code>the JSONRPC request</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>a list containing the parameters</code> of <code>the JSONRPC request</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a dict with the parsed result of the request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpc_request(self, method, params, result_handler=None):
    &#34;&#34;&#34;
    Method that handles the actual RPC request to the Substrate node. The other implemented functions eventually
    use this method to perform the request.

    Parameters
    ----------
    result_handler: Callback of function that processes the result received from the node
    method: method of the JSONRPC request
    params: a list containing the parameters of the JSONRPC request

    Returns
    -------
    a dict with the parsed result of the request.
    &#34;&#34;&#34;
    payload = {
        &#34;jsonrpc&#34;: &#34;2.0&#34;,
        &#34;method&#34;: method,
        &#34;params&#34;: params,
        &#34;id&#34;: self.request_id
    }

    self.debug_message(&#39;RPC request #{}: &#34;{}&#34;&#39;.format(self.request_id, method))

    if self.websocket:
        try:
            self.websocket.send(json.dumps(payload))

            if callable(result_handler):
                # If result handler is set, pass result through and loop until handler return not None
                event_number = 0
                json_body = None
                while not json_body:
                    result = json.loads(self.websocket.recv())
                    self.debug_message(&#34;Websocket result [{}] Received from node: {}&#34;.format(event_number, result))

                    # Check if response has error
                    if &#39;error&#39; in result:
                        raise SubstrateRequestException(result[&#39;error&#39;])

                    callback_result = result_handler(result)
                    if callback_result:
                        json_body = callback_result

                    event_number += 1
            else:

                json_body = json.loads(self.websocket.recv())

        except WebSocketConnectionClosedException:
            if self.url:
                # Try to reconnect websocket and retry rpc_request
                self.debug_message(&#34;Connection Closed; Trying to reconnecting...&#34;)
                self.connect_websocket()

                return self.rpc_request(method=method, params=params, result_handler=result_handler)
            else:
                # websocket connection is externally created, re-raise exception
                raise

    else:

        if result_handler:
            raise ConfigurationError(&#34;Result handlers only available for websockets (ws://) connections&#34;)

        response = requests.request(&#34;POST&#34;, self.url, data=json.dumps(payload), headers=self.default_headers)

        if response.status_code != 200:
            raise SubstrateRequestException(&#34;RPC request failed with HTTP status code {}&#34;.format(response.status_code))

        json_body = response.json()

    self.request_id += 1
    return json_body</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.serialize_constant"><code class="name flex">
<span>def <span class="ident">serialize_constant</span></span>(<span>self, constant, module, spec_version_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to serialize a constant</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>constant</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_constant(self, constant, module, spec_version_id):
    &#34;&#34;&#34;
    Helper function to serialize a constant

    Parameters
    ----------
    constant
    module
    spec_version_id

    Returns
    -------

    &#34;&#34;&#34;
    try:
        value_obj = ScaleDecoder.get_decoder_class(
            type_string=constant.type, data=ScaleBytes(constant.constant_value), runtime_config=self.runtime_config
        )
        constant_decoded_value = value_obj.decode()
    except Exception:
        constant_decoded_value = &#39;[decoding error]&#39;

    return {
        &#34;constant_name&#34;: constant.name,
        &#34;constant_type&#34;: constant.type,
        &#34;constant_value&#34;: constant_decoded_value,
        &#34;constant_value_scale&#34;: constant.constant_value,
        &#34;documentation&#34;: &#39;\n&#39;.join(constant.docs),
        &#34;module_id&#34;: module.get_identifier(),
        &#34;module_prefix&#34;: module.prefix,
        &#34;module_name&#34;: module.name,
        &#34;spec_version&#34;: spec_version_id
    }</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.serialize_module_call"><code class="name flex">
<span>def <span class="ident">serialize_module_call</span></span>(<span>self, module, call, spec_version, call_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to serialize a call function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>call</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>call_index</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_module_call(self, module, call, spec_version, call_index):
    &#34;&#34;&#34;
    Helper function to serialize a call function

    Parameters
    ----------
    module
    call
    spec_version
    call_index

    Returns
    -------

    &#34;&#34;&#34;
    return {
        &#34;call_id&#34;: call.get_identifier(),
        &#34;call_name&#34;: call.name,
        &#34;call_args&#34;: [call_arg.value for call_arg in call.args],
        &#34;lookup&#34;: &#39;0x{}&#39;.format(call_index),
        &#34;documentation&#34;: &#39;\n&#39;.join(call.docs),
        &#34;module_id&#34;: module.get_identifier(),
        &#34;module_prefix&#34;: module.prefix,
        &#34;module_name&#34;: module.name,
        &#34;spec_version&#34;: spec_version
    }</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.serialize_module_error"><code class="name flex">
<span>def <span class="ident">serialize_module_error</span></span>(<span>self, module, error, spec_version)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to serialize an error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>error</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_module_error(self, module, error, spec_version):
    &#34;&#34;&#34;
    Helper function to serialize an error

    Parameters
    ----------
    module
    error
    spec_version

    Returns
    -------

    &#34;&#34;&#34;
    return {
        &#34;error_name&#34;: error.name,
        &#34;documentation&#34;: &#39;\n&#39;.join(error.docs),
        &#34;module_id&#34;: module.get_identifier(),
        &#34;module_prefix&#34;: module.prefix,
        &#34;module_name&#34;: module.name,
        &#34;spec_version&#34;: spec_version
    }</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.serialize_module_event"><code class="name flex">
<span>def <span class="ident">serialize_module_event</span></span>(<span>self, module, event, spec_version, event_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to serialize an event</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>event</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>event_index</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_module_event(self, module, event, spec_version, event_index):
    &#34;&#34;&#34;
    Helper function to serialize an event

    Parameters
    ----------
    module
    event
    spec_version
    event_index

    Returns
    -------

    &#34;&#34;&#34;
    return {
        &#34;event_id&#34;: event.name,
        &#34;event_name&#34;: event.name,
        &#34;event_args&#34;: [
              {
                &#34;event_arg_index&#34;: idx,
                &#34;type&#34;: arg
              } for idx, arg in enumerate(event.args)
            ],
        &#34;lookup&#34;: &#39;0x{}&#39;.format(event_index),
        &#34;documentation&#34;: &#39;\n&#39;.join(event.docs),
        &#34;module_id&#34;: module.get_identifier(),
        &#34;module_prefix&#34;: module.prefix,
        &#34;module_name&#34;: module.name,
        &#34;spec_version&#34;: spec_version
    }</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.serialize_storage_item"><code class="name flex">
<span>def <span class="ident">serialize_storage_item</span></span>(<span>self, storage_item, module, spec_version_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to serialize a storage item</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>storage_item</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>module</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>spec_version_id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_storage_item(self, storage_item, module, spec_version_id):
    &#34;&#34;&#34;
    Helper function to serialize a storage item

    Parameters
    ----------
    storage_item
    module
    spec_version_id

    Returns
    -------

    &#34;&#34;&#34;
    storage_dict = {
        &#34;storage_name&#34;: storage_item.name,
        &#34;storage_modifier&#34;: storage_item.modifier,
        &#34;storage_fallback_scale&#34;: storage_item.fallback,
        &#34;storage_fallback&#34;: None,
        &#34;documentation&#34;: &#39;\n&#39;.join(storage_item.docs),
        &#34;module_id&#34;: module.get_identifier(),
        &#34;module_prefix&#34;: module.prefix,
        &#34;module_name&#34;: module.name,
        &#34;spec_version&#34;: spec_version_id,
        &#34;type_key1&#34;: None,
        &#34;type_key2&#34;: None,
        &#34;type_hasher_key1&#34;: None,
        &#34;type_hasher_key2&#34;: None,
        &#34;type_value&#34;: None,
        &#34;type_is_linked&#34;: None
    }

    type_class, type_info = next(iter(storage_item.type.items()))

    storage_dict[&#34;type_class&#34;] = type_class

    if type_class == &#39;PlainType&#39;:
        storage_dict[&#34;type_value&#34;] = type_info

    elif type_class == &#39;MapType&#39;:
        storage_dict[&#34;type_value&#34;] = type_info[&#34;value&#34;]
        storage_dict[&#34;type_key1&#34;] = type_info[&#34;key&#34;]
        storage_dict[&#34;type_hasher_key1&#34;] = type_info[&#34;hasher&#34;]
        storage_dict[&#34;type_is_linked&#34;] = type_info[&#34;isLinked&#34;]

    elif type_class == &#39;DoubleMapType&#39;:

        storage_dict[&#34;type_value&#34;] = type_info[&#34;value&#34;]
        storage_dict[&#34;type_key1&#34;] = type_info[&#34;key1&#34;]
        storage_dict[&#34;type_key2&#34;] = type_info[&#34;key2&#34;]
        storage_dict[&#34;type_hasher_key1&#34;] = type_info[&#34;hasher&#34;]
        storage_dict[&#34;type_hasher_key2&#34;] = type_info[&#34;key2Hasher&#34;]

    if storage_item.fallback != &#39;0x00&#39;:
        # Decode fallback
        try:
            fallback_obj = ScaleDecoder.get_decoder_class(
                type_string=storage_dict[&#34;type_value&#34;],
                data=ScaleBytes(storage_item.fallback),
                runtime_config=self.runtime_config
            )
            storage_dict[&#34;storage_fallback&#34;] = fallback_obj.decode()
        except Exception:
            storage_dict[&#34;storage_fallback&#34;] = &#39;[decoding error]&#39;

    return storage_dict</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.ss58_decode"><code class="name flex">
<span>def <span class="ident">ss58_decode</span></span>(<span>self, ss58_address: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to decode a SS58 address to a public key</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ss58_address</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Public <a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ss58_decode(self, ss58_address: str) -&gt; str:
    &#34;&#34;&#34;
    Helper function to decode a SS58 address to a public key

    Parameters
    ----------
    ss58_address

    Returns
    -------
    Public key
    &#34;&#34;&#34;
    return ss58_decode(ss58_address, valid_ss58_format=self.ss58_format)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.ss58_encode"><code class="name flex">
<span>def <span class="ident">ss58_encode</span></span>(<span>self, public_key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to encode a public key to SS58 address</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>public_key</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SS58 address</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ss58_encode(self, public_key: str) -&gt; str:
    &#34;&#34;&#34;
    Helper function to encode a public key to SS58 address

    Parameters
    ----------
    public_key

    Returns
    -------
    SS58 address
    &#34;&#34;&#34;
    return ss58_encode(public_key, ss58_format=self.ss58_format)</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.submit_extrinsic"><code class="name flex">
<span>def <span class="ident">submit_extrinsic</span></span>(<span>self, extrinsic, wait_for_inclusion=False, wait_for_finalization=False) ‑> <a title="substrateinterface.base.ExtrinsicReceipt" href="base.html#substrateinterface.base.ExtrinsicReceipt">ExtrinsicReceipt</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>extrinsic</code></strong> :&ensp;<code>ExtrinsicsDecoder The extinsic to be send to the network</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>wait_for_inclusion</code></strong> :&ensp;<code>wait until extrinsic is included in a block (only works for websocket connections)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>wait_for_finalization</code></strong> :&ensp;<code>wait until extrinsic is finalized (only works for websocket connections)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The hash</code> of <code>the extrinsic submitted to the network</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_extrinsic(self, extrinsic, wait_for_inclusion=False, wait_for_finalization=False) -&gt; &#34;ExtrinsicReceipt&#34;:
    &#34;&#34;&#34;

    Parameters
    ----------
    extrinsic: ExtrinsicsDecoder The extinsic to be send to the network
    wait_for_inclusion: wait until extrinsic is included in a block (only works for websocket connections)
    wait_for_finalization: wait until extrinsic is finalized (only works for websocket connections)

    Returns
    -------
    The hash of the extrinsic submitted to the network

    &#34;&#34;&#34;

    # Check requirements
    if extrinsic.__class__.__name__ != &#39;ExtrinsicsDecoder&#39;:
        raise TypeError(&#34;&#39;extrinsic&#39; must be of type ExtrinsicsDecoder&#34;)

    def result_handler(result):
        # Check if extrinsic is included and finalized
        if &#39;params&#39; in result and type(result[&#39;params&#39;][&#39;result&#39;]) is dict:
            if &#39;finalized&#39; in result[&#39;params&#39;][&#39;result&#39;] and wait_for_finalization:
                return {
                    &#39;block_hash&#39;: result[&#39;params&#39;][&#39;result&#39;][&#39;finalized&#39;],
                    &#39;extrinsic_hash&#39;: &#39;0x{}&#39;.format(extrinsic.extrinsic_hash),
                    &#39;finalized&#39;: True
                }
            elif &#39;inBlock&#39; in result[&#39;params&#39;][&#39;result&#39;] and wait_for_inclusion and not wait_for_finalization:
                return {
                    &#39;block_hash&#39;: result[&#39;params&#39;][&#39;result&#39;][&#39;inBlock&#39;],
                    &#39;extrinsic_hash&#39;: &#39;0x{}&#39;.format(extrinsic.extrinsic_hash),
                    &#39;finalized&#39;: False
                }

    if wait_for_inclusion or wait_for_finalization:
        response = self.rpc_request(
            &#34;author_submitAndWatchExtrinsic&#34;,
            [str(extrinsic.data)],
            result_handler=result_handler
        )

        result = ExtrinsicReceipt(
            substrate=self,
            extrinsic_hash=response[&#39;extrinsic_hash&#39;],
            block_hash=response[&#39;block_hash&#39;],
            finalized=response[&#39;finalized&#39;]
        )

    else:

        response = self.rpc_request(&#34;author_submitExtrinsic&#34;, [str(extrinsic.data)])

        if &#39;result&#39; not in response:
            raise SubstrateRequestException(response.get(&#39;error&#39;))

        result = ExtrinsicReceipt(
            substrate=self,
            extrinsic_hash=response[&#39;result&#39;]
        )

    return result</code></pre>
</details>
</dd>
<dt id="substrateinterface.SubstrateInterface.update_type_registry_presets"><code class="name flex">
<span>def <span class="ident">update_type_registry_presets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_type_registry_presets(self):
    try:
        update_type_registries()
        return True
    except Exception:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="substrateinterface.base" href="base.html">substrateinterface.base</a></code></li>
<li><code><a title="substrateinterface.constants" href="constants.html">substrateinterface.constants</a></code></li>
<li><code><a title="substrateinterface.contracts" href="contracts.html">substrateinterface.contracts</a></code></li>
<li><code><a title="substrateinterface.exceptions" href="exceptions.html">substrateinterface.exceptions</a></code></li>
<li><code><a title="substrateinterface.key" href="key.html">substrateinterface.key</a></code></li>
<li><code><a title="substrateinterface.utils" href="utils/index.html">substrateinterface.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="substrateinterface.ContractCode" href="#substrateinterface.ContractCode">ContractCode</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.ContractCode.create_from_code_hash" href="#substrateinterface.ContractCode.create_from_code_hash">create_from_code_hash</a></code></li>
<li><code><a title="substrateinterface.ContractCode.create_from_contract_files" href="#substrateinterface.ContractCode.create_from_contract_files">create_from_contract_files</a></code></li>
<li><code><a title="substrateinterface.ContractCode.deploy" href="#substrateinterface.ContractCode.deploy">deploy</a></code></li>
<li><code><a title="substrateinterface.ContractCode.upload_wasm" href="#substrateinterface.ContractCode.upload_wasm">upload_wasm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.ContractExecutionReceipt" href="#substrateinterface.ContractExecutionReceipt">ContractExecutionReceipt</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.ContractExecutionReceipt.contract_events" href="#substrateinterface.ContractExecutionReceipt.contract_events">contract_events</a></code></li>
<li><code><a title="substrateinterface.ContractExecutionReceipt.create_from_extrinsic_receipt" href="#substrateinterface.ContractExecutionReceipt.create_from_extrinsic_receipt">create_from_extrinsic_receipt</a></code></li>
<li><code><a title="substrateinterface.ContractExecutionReceipt.process_events" href="#substrateinterface.ContractExecutionReceipt.process_events">process_events</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.ContractInstance" href="#substrateinterface.ContractInstance">ContractInstance</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.ContractInstance.create_from_address" href="#substrateinterface.ContractInstance.create_from_address">create_from_address</a></code></li>
<li><code><a title="substrateinterface.ContractInstance.exec" href="#substrateinterface.ContractInstance.exec">exec</a></code></li>
<li><code><a title="substrateinterface.ContractInstance.read" href="#substrateinterface.ContractInstance.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.ContractMetadata" href="#substrateinterface.ContractMetadata">ContractMetadata</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.ContractMetadata.create_from_file" href="#substrateinterface.ContractMetadata.create_from_file">create_from_file</a></code></li>
<li><code><a title="substrateinterface.ContractMetadata.generate_constructor_data" href="#substrateinterface.ContractMetadata.generate_constructor_data">generate_constructor_data</a></code></li>
<li><code><a title="substrateinterface.ContractMetadata.generate_message_data" href="#substrateinterface.ContractMetadata.generate_message_data">generate_message_data</a></code></li>
<li><code><a title="substrateinterface.ContractMetadata.get_event_data" href="#substrateinterface.ContractMetadata.get_event_data">get_event_data</a></code></li>
<li><code><a title="substrateinterface.ContractMetadata.get_return_type_string_for_message" href="#substrateinterface.ContractMetadata.get_return_type_string_for_message">get_return_type_string_for_message</a></code></li>
<li><code><a title="substrateinterface.ContractMetadata.get_type_string_for_metadata_type" href="#substrateinterface.ContractMetadata.get_type_string_for_metadata_type">get_type_string_for_metadata_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.ExtrinsicReceipt" href="#substrateinterface.ExtrinsicReceipt">ExtrinsicReceipt</a></code></h4>
<ul class="two-column">
<li><code><a title="substrateinterface.ExtrinsicReceipt.error_message" href="#substrateinterface.ExtrinsicReceipt.error_message">error_message</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.extrinsic" href="#substrateinterface.ExtrinsicReceipt.extrinsic">extrinsic</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.extrinsic_idx" href="#substrateinterface.ExtrinsicReceipt.extrinsic_idx">extrinsic_idx</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.get" href="#substrateinterface.ExtrinsicReceipt.get">get</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.is_success" href="#substrateinterface.ExtrinsicReceipt.is_succes">is_success</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.process_events" href="#substrateinterface.ExtrinsicReceipt.process_events">process_events</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.retrieve_extrinsic" href="#substrateinterface.ExtrinsicReceipt.retrieve_extrinsic">retrieve_extrinsic</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.total_fee_amount" href="#substrateinterface.ExtrinsicReceipt.total_fee_amount">total_fee_amount</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.triggered_events" href="#substrateinterface.ExtrinsicReceipt.triggered_events">triggered_events</a></code></li>
<li><code><a title="substrateinterface.ExtrinsicReceipt.weight" href="#substrateinterface.ExtrinsicReceipt.weight">weight</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.Keypair" href="#substrateinterface.Keypair">Keypair</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.Keypair.create_from_mnemonic" href="#substrateinterface.Keypair.create_from_mnemonic">create_from_mnemonic</a></code></li>
<li><code><a title="substrateinterface.Keypair.create_from_private_key" href="#substrateinterface.Keypair.create_from_private_key">create_from_private_key</a></code></li>
<li><code><a title="substrateinterface.Keypair.create_from_seed" href="#substrateinterface.Keypair.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="substrateinterface.Keypair.create_from_uri" href="#substrateinterface.Keypair.create_from_uri">create_from_uri</a></code></li>
<li><code><a title="substrateinterface.Keypair.generate_mnemonic" href="#substrateinterface.Keypair.generate_mnemonic">generate_mnemonic</a></code></li>
<li><code><a title="substrateinterface.Keypair.sign" href="#substrateinterface.Keypair.sign">sign</a></code></li>
<li><code><a title="substrateinterface.Keypair.verify" href="#substrateinterface.Keypair.verify">verify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.KeypairType" href="#substrateinterface.KeypairType">KeypairType</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.KeypairType.ED25519" href="#substrateinterface.KeypairType.ED25519">ED25519</a></code></li>
<li><code><a title="substrateinterface.KeypairType.SR25519" href="#substrateinterface.KeypairType.SR25519">SR25519</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="substrateinterface.SubstrateInterface" href="#substrateinterface.SubstrateInterface">SubstrateInterface</a></code></h4>
<ul class="">
<li><code><a title="substrateinterface.SubstrateInterface.chain" href="#substrateinterface.SubstrateInterface.chain">chain</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.compose_call" href="#substrateinterface.SubstrateInterface.compose_call">compose_call</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.connect_websocket" href="#substrateinterface.SubstrateInterface.connect_websocket">connect_websocket</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.convert_storage_parameter" href="#substrateinterface.SubstrateInterface.convert_storage_parameter">convert_storage_parameter</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.create_signed_extrinsic" href="#substrateinterface.SubstrateInterface.create_signed_extrinsic">create_signed_extrinsic</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.create_unsigned_extrinsic" href="#substrateinterface.SubstrateInterface.create_unsigned_extrinsic">create_unsigned_extrinsic</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.debug_message" href="#substrateinterface.SubstrateInterface.debug_message">debug_message</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.decode_scale" href="#substrateinterface.SubstrateInterface.decode_scale">decode_scale</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.encode_scale" href="#substrateinterface.SubstrateInterface.encode_scale">encode_scale</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.generate_signature_payload" href="#substrateinterface.SubstrateInterface.generate_signature_payload">generate_signature_payload</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.generate_storage_hash" href="#substrateinterface.SubstrateInterface.generate_storage_hash">generate_storage_hash</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_account_nonce" href="#substrateinterface.SubstrateInterface.get_account_nonce">get_account_nonce</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_events" href="#substrateinterface.SubstrateInterface.get_block_events">get_block_events</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_extrinsics" href="#substrateinterface.SubstrateInterface.get_block_extrinsics">get_block_extrinsics</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_hash" href="#substrateinterface.SubstrateInterface.get_block_hash">get_block_hash</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_header" href="#substrateinterface.SubstrateInterface.get_block_header">get_block_header</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_metadata" href="#substrateinterface.SubstrateInterface.get_block_metadata">get_block_metadata</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_number" href="#substrateinterface.SubstrateInterface.get_block_number">get_block_number</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_block_runtime_version" href="#substrateinterface.SubstrateInterface.get_block_runtime_version">get_block_runtime_version</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_chain_block" href="#substrateinterface.SubstrateInterface.get_chain_block">get_chain_block</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_chain_finalised_head" href="#substrateinterface.SubstrateInterface.get_chain_finalised_head">get_chain_finalised_head</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_chain_head" href="#substrateinterface.SubstrateInterface.get_chain_head">get_chain_head</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_events" href="#substrateinterface.SubstrateInterface.get_events">get_events</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_call_function" href="#substrateinterface.SubstrateInterface.get_metadata_call_function">get_metadata_call_function</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_call_functions" href="#substrateinterface.SubstrateInterface.get_metadata_call_functions">get_metadata_call_functions</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_constant" href="#substrateinterface.SubstrateInterface.get_metadata_constant">get_metadata_constant</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_constants" href="#substrateinterface.SubstrateInterface.get_metadata_constants">get_metadata_constants</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_error" href="#substrateinterface.SubstrateInterface.get_metadata_error">get_metadata_error</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_errors" href="#substrateinterface.SubstrateInterface.get_metadata_errors">get_metadata_errors</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_event" href="#substrateinterface.SubstrateInterface.get_metadata_event">get_metadata_event</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_events" href="#substrateinterface.SubstrateInterface.get_metadata_events">get_metadata_events</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_modules" href="#substrateinterface.SubstrateInterface.get_metadata_modules">get_metadata_modules</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_storage_function" href="#substrateinterface.SubstrateInterface.get_metadata_storage_function">get_metadata_storage_function</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_metadata_storage_functions" href="#substrateinterface.SubstrateInterface.get_metadata_storage_functions">get_metadata_storage_functions</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_payment_info" href="#substrateinterface.SubstrateInterface.get_payment_info">get_payment_info</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_runtime_block" href="#substrateinterface.SubstrateInterface.get_runtime_block">get_runtime_block</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_runtime_events" href="#substrateinterface.SubstrateInterface.get_runtime_events">get_runtime_events</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_runtime_metadata" href="#substrateinterface.SubstrateInterface.get_runtime_metadata">get_runtime_metadata</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_runtime_state" href="#substrateinterface.SubstrateInterface.get_runtime_state">get_runtime_state</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_storage" href="#substrateinterface.SubstrateInterface.get_storage">get_storage</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_storage_by_key" href="#substrateinterface.SubstrateInterface.get_storage_by_key">get_storage_by_key</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_type_definition" href="#substrateinterface.SubstrateInterface.get_type_definition">get_type_definition</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.get_type_registry" href="#substrateinterface.SubstrateInterface.get_type_registry">get_type_registry</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.init_runtime" href="#substrateinterface.SubstrateInterface.init_runtime">init_runtime</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.iterate_map" href="#substrateinterface.SubstrateInterface.iterate_map">iterate_map</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.name" href="#substrateinterface.SubstrateInterface.name">name</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.process_metadata_typestring" href="#substrateinterface.SubstrateInterface.process_metadata_typestring">process_metadata_typestring</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.properties" href="#substrateinterface.SubstrateInterface.properties">properties</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.query" href="#substrateinterface.SubstrateInterface.query">query</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.rpc_request" href="#substrateinterface.SubstrateInterface.rpc_request">rpc_request</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.serialize_constant" href="#substrateinterface.SubstrateInterface.serialize_constant">serialize_constant</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.serialize_module_call" href="#substrateinterface.SubstrateInterface.serialize_module_call">serialize_module_call</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.serialize_module_error" href="#substrateinterface.SubstrateInterface.serialize_module_error">serialize_module_error</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.serialize_module_event" href="#substrateinterface.SubstrateInterface.serialize_module_event">serialize_module_event</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.serialize_storage_item" href="#substrateinterface.SubstrateInterface.serialize_storage_item">serialize_storage_item</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.ss58_decode" href="#substrateinterface.SubstrateInterface.ss58_decode">ss58_decode</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.ss58_encode" href="#substrateinterface.SubstrateInterface.ss58_encode">ss58_encode</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.ss58_format" href="#substrateinterface.SubstrateInterface.ss58_format">ss58_format</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.submit_extrinsic" href="#substrateinterface.SubstrateInterface.submit_extrinsic">submit_extrinsic</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.token_decimals" href="#substrateinterface.SubstrateInterface.token_decimals">token_decimals</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.token_symbol" href="#substrateinterface.SubstrateInterface.token_symbol">token_symbol</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.update_type_registry_presets" href="#substrateinterface.SubstrateInterface.update_type_registry_presets">update_type_registry_presets</a></code></li>
<li><code><a title="substrateinterface.SubstrateInterface.version" href="#substrateinterface.SubstrateInterface.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
